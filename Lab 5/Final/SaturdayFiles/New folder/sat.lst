WARNING: EXTCODE CODE AREA DO NOT CONTAIN RELOCATED ADDRESSES.
THIS WILL BE REMEDIED IN A LATER RELEASE.
--- 0000           ; Robert Cory Molloy & Oscar Andrade
--- 0000           ; ME 305 - 02 :: Intro to Mechatronics
--- 0000           ; Labratory 5 :: Motor Controller 
--- 0000           
--- 0000           ;==================== Assembler Equates ====================
--- 0000           
 0280           ENCODER		       		= $0280				; Encoder Address 
 0028           PORTJ              		= $0028             ; Port J Address
 0029           DDRJ	   		   		= $0029             ; Make Port J an Output Address
 0010           pin5           	   		= 0b00010000        ; Pin 5 of Port J
 0080           TIOS               		= $0080             ; Timer Output Compare Address
 008E           TFLG1              		= $008E             ; Timer Flag Register Address
 0086           TSCR               		= $0086             ; Timer System Control Register Address
 0090           TC0H               		= $0090             ; Timer Channel Zero High Address
 0084           TCNT               		= $0084             ; Timer Count Register High and Low Address
 008C           TMSK1              		= $008C             ; Timer Mask Address
 0089           TCTL2              		= $0089             ; Timer Control Register Address
 0BB2           VREF_BUF		   		= $BB2			    ; Buffer Address for Reference Velocity
 0BB6           VACT_BUF		   		= $BB6			    ; Buffer Address for Actual Velocity
 0BBA           ERROR_BUF		   		= $BBA			    ; Buffer Address for Calculated Error
 0BBE           EFFORT_BUF		   		= $BBE				; Buffer Address for Calculated Effort
 0BC2           KI_BUF		   	   		= $BC2              ; Buffer Address for Integral Constant
 0BC7           KP_BUF		   	   		= $BC7			 	; Buffer Address for Proportional Constant
--- 0000           
--- 0000           ;==================== RAM area ====================
                .area bss
                
                ; Task Variables
                
 0800            mmState::                               .blkb 1                         ; Master Mind State Variable
 0801            kpdState::                              .blkb 1                         ; Key Pad Driver State Variable
 0802            displayState::                  .blkb 1                         ; Display State Variable
 0803            backspaceState::                .blkb 1                         ; Backspace State Variable
 0804            stateVariableState::    .blkb 1                         ; State Variable State Variable
 0805            tc0State::                              .blkb 1                         ; Timer Channel Zero State Variable
 0806            
 0806            ; ISR Variables
 0806            
 0806            V_Ref::                 .blkb 2                         ; Voltage Reference Inputted By User [BDI/BTI]
 0808            V_Act::                 .blkb 2                 ; Actual Voltage at Encoder
 080A            Error::                         .blkb 2                         ; V_Ref - V_act
 080C            E_Sum::                 .blkb 2                 ; Integral Error Sum
 080E            KiplusKp::              .blkb 2                 ; (Kp*Error)+(Ki/s*Esum)
 0810            A_Prime::               .blkb 2                 ; [A +/- 2458]
 0812            A_Star::                .blkb 2                 ; Dac Value 
 0814            Ki::                    .blkb 2                 ; Integral Control
 0816            oldKi::                                 .blkb 2                         ; Old Integral Control
 0818            Kp::                    .blkb 2                 ; Proportional Control
 081A            Kpdivs::                .blkb 2                 ; Kp*Error, After edivs Command
 081C            Kidivs::                .blkb 2                 ; Ki*Esum, After edivs Command
 081E            Dac_Value::             .blkb 2                         ; Voltage Value to be Fed to DAC
 0820            Theta_New::             .blkb 2                 ; New Displacment Interval Read from Encoder
 0822            Theta_Old::             .blkb 2                 ; Previous Displacement Interval Read from Encoder
 0824            Effort::                                .blkb 2                 ; Value for Calculated Effort  
 0826            slopeTimesDacValue::    .blkb 2                         ;
 0828            bConstant::                             .blkb 2                         ;
 082A            DAC_PLUS_FIVE::         .blkb 2 
 082C            SS_ERROR::              .blkb 2
 082E            
 082E            ;==================== Storing Variables ====================
 082E            
 082E            keyStore::                              .blkb 1                         ; Stores Most Recent Digit Pressed
 082F            buffer::                                .blkb 6                         ; Stores All Digits for Processing to Value
 0835            result::                                .blkb 2                         ; Stores Converted ASCII Numbers Before Push to Value
 0837            updateBuffer::                  .blkb 5                         ; Stores BCD Converted Value to Convert to ASCII Values
 083C            updateResult::                  .blkb 2                         ; Stores Converted BCD to ASCII Values for Template Buffers
 083E            stateVariable::                 .blkb 1
 083F            Dac_ValueMinusSixVolts::.blkb 2
 0841            Dac_ValueTimesHundred:: .blkb 2
 0843            
 0843            ;==================== Counter Variables ====================
 0843            
 0843            digitCounter::                  .blkb 1                         ; Counts Up Current Digits Input into Buffer
 0844            updateCounter::                 .blkb 1                         ; Counts Up to See if All BCD to ASCII Values Are Done 
 0845            LCDUpdateCounter::              .blkb 1                         ; Counts Down From 256 to 0 Interrupts to Update the Template
 0846            
 0846            ;==================== Flag Variables ====================
 0846            
 0846            keyFlag::                               .blkb 1                         ; Notifies Program a Key Has Been Pressed
 0847            echoFlag::                              .blkb 1                         ; Notifies Program that a Key Needs to Be Echoed
 0848            enterFlag::                             .blkb 1                         ; Notifies Program that Enter Procedure is Done
 0849            firstChar::                             .blkb 1                         ; Notifies Program the First Character is Ready
 084A            backspaceFlag::                 .blkb 1                         ; Notifies Program that a Entered Digit Needs to Be Cleared
 084B            digitFlag::                             .blkb 1                         ;
 084C            charFlag::                              .blkb 1                         ;
 084D            
 084D            RUN::                           .blkb 1                         ; Notifies The Program That The DAC Can Recieve Voltage
 084E            loopSetFlag::                   .blkb 1                         ; Nofities The Program That The Loop is Open or Closed
 084F            stateVariableFlag::             .blkb 1                         ; Notifies The Program That That The State Variables Need to Be Updated
 0850            autoManualFlag::                .blkb 1                         ; Notifies The Program Whether the Template Updates Automatically Or Manually
 0851            LCDUpdateFlag::                 .blkb 1                         ; Notifies The Program to Update the LCD Template
 0852            
 0852            VRefFlag::                              .blkb 1                         ; Notifies The Program The VRef (C Key) Was Pressed
 0853            VActFlag::                              .blkb 1                         ; Notifies The Program The VAct is Ready to Be Updated
 0854            effortFlag::                    .blkb 1                         ; Notifies The Program The Effort is Ready to Be Updated
 0855            errorFlag::                     .blkb 1                         ; Notifies The Program The Error is Ready to Be Updated
 0856            KiFlag::                        .blkb 1                         ; Notifies The Program That KI is Ready to Be Updated
 0857            KpFlag::                        .blkb 1                         ; Notifies The Program That KP is Ready to Be Updated
 0858            
 0858            AFlag::                                 .blkb 1                         ; Notifies The Program That A Has Been Pressed
 0859            BFlag::                                 .blkb 1                         ; Notifies The Program That B Has Been Pressed
 085A            CFlag::                                 .blkb 1                         ; Notifies The Program That C Has Been Pressed
 085B            DFlag::                                 .blkb 1                         ; Notifies The Program That D Has Been Pressed
 085C            EFlag::                                 .blkb 1                         ; Notifies The Program That E Has Been Pressed
 085D            FFlag::                                 .blkb 1                         ; Notifies The Program That F Has Been Pressed
 085E            firstKiFlag::                   .blkb 1
 085F            
 085F            
 085F            onPrintFlag::                   .blkb 1                         ; Notifies The Program That the R State Var. Should Be Printed
 0860            offPrintFlag::                  .blkb 1                         ; Notifies The Program That the S State Var. Should Be Printed
 0861            openLoopPrintFlag::             .blkb 1                         ; Notifies The Program That the OL State Var. Should Be Printed
 0862            closedLoopPrintFlag::   .blkb 1                         ; Notifies The Program That the CL State Var. Should Be Printed
 0863            autoPrintFlag::                 .blkb 1                         ; Notifies The Program That the A State Var. Should Be Printed
 0864            manualPrintFlag::               .blkb 1                         ; Notifies The Program That the M State Var. Should Be Printed
 0865            VRefNegPrintFlag::              .blkb 1                         ; Notifies The Program That the '+' Should Be Printed
 0866            VRefPosPrintFlag::              .blkb 1                         ; Notifies The Program That the '-' Should Be Printed
 0867            backspacePrint::                .blkb 1                         ; Notifies The Program That a Backspace Should Be Printed
 0868            
 0868            VRefPromptFlag::                .blkb 1                         ; Notifies The Program to Print the VRef Prompt
 0869            KiPromptFlag::                  .blkb 1                         ; Notifies The Program to Print the Ki Prompt
 086A            KpPromptFlag::                  .blkb 1                         ; Notifies The Program to Print the Kp Prompt
 086B            
 086B            digitAllowed::                  .blkb 1                         ; Notifies The Program That A Digit is or is not Allowed to Be Entered
 086C            VRefSignFlag::                  .blkb 1                         ; Notifies The Program That A '+' or '-' Has Been Entered 
 086D            
 086D            updateValuesFlag::              .blkb 1                         ; Notifies The Program to Update the Template Values
 086E            updateLine1Flag::               .blkb 1                         ; Notifies The Program to Update Line 1 in the Template
 086F            updateLine2Flag::               .blkb 1                         ; Notifies The Program to Update Line 2 in the Template
 0870            
 0870            promptUpFlag::                  .blkb 1                         ; Notifies The Program That a Prompt Has Been Printed
 0871            
 0871            ; Sign Variables
 0871            
 0871            VRefSign::                              .blkb 1                         ; Notifies The Program If VRef is '+' or '-'
 0872            VActSign::                              .blkb 1                         ; Notifies The Program If VAct is '+' or '-'
 0873            effortSign::                    .blkb 1                         ; Notifies The Program If Effort is '+' or '-'
 0874            errorSign::                             .blkb 1                         ; Notifies The Program If Error is '+' or '-'
 0875            
 0875            ; Other Variables
 0875            
 0875            pointer::                       .blkb 2                         ; Holds the Next Address of buffer
 0877            updatePointer::                 .blkb 2                         ; Holds the Next Address of updateBuffer        
 0879            displayPointer::                .blkb 2                 ; Holds the Next ASCII Value to Be Printed
 087B            
 087B            ;==================== Flash ====================
 087B            
                .area text
                
                ;==================================  Main Program  =============================
                
 C055            _main::
 C055             
 C055  16C067            jsr     INIT                    ; Initialization
 C058             
 C058            TOP: 
 C058  00        bgnd
 C059  16C074            jsr     MASTERMIND                      ; Mastermind Sub-Routines
 C05C             
 C05C  16C8CB            jsr     KPD                                     ; Key Pad Driver Sub-Routines
 C05F             
 C05F  16C903            jsr     DISPLAY                 ; Display Sub-Routines
 C062             
 C062  16CCEE            jsr             TIMER_C0                ; Timer Channel Zero Sub-Routines
 C065            
 C065  20F1              bra             TOP
 C067                    
 C067            ;================================  Initialization  =============================        
 C067                    
 C067            INIT:
 C067            
 C067  790800            clr             mmState                         ; Initialize All Sub-Routine State Variables to State 0
 C06A  790801            clr             kpdState            ; Clear Keypad Driver States Variable
 C06D  790802            clr             displayState        ; Clear Displaysate State Variable
 C070  790803            clr             backspaceState      ; Clear Backspace State Variable
 C073  3D                rts     
 C074                    
 C074            ;========================== Mastermind Sub-Routine =============================
 C074            
 C074            MASTERMIND:
 C074            
 C074  B60800            ldaa    mmState                         ; Grabbing the current state of Mastermind & Branching
 C077  18270024          lbeq    mmstate0                        ; Initialization of Mastermind & Buffer 
 C07B  43                deca
 C07C  1827005C          lbeq    mmstate1                        ; Splash Screen and Setting Displays Flags
 C080  43                deca
 C081  18270094          lbeq    mmstate2                        ; Mastermind Hub
 C085  43                deca
 C086  182701E0          lbeq    mmstate3                        ; Backspace State
 C08A  43                deca
 C08B  18270208          lbeq    mmstate4                        ; Enter State
 C08F  43                deca
 C090  1827032C          lbeq    mmstate5                        ; Digit State
 C094  43                deca
 C095  18270362          lbeq    mmstate6                        ; Character State
 C099  43                deca    
 C09A  182704DC          lbeq    mmstate7                        ; Update Values State
 C09E  3D                rts                                                     ; Return to Main 
 C09F            
 C09F            ;=========== Mastermind State 0 - Initialization of Mastermind & Buffer ========
 C09F            
 C09F            mmstate0:	
 C09F            	
 C09F  16C84E            jsr             CLEAR_TEMPLATE                                          ; Clear the LCD Template Buffers
 C0A2  79082F            clr             buffer                                                  ; Clear the buffer Variable
 C0A5  790837            clr             updateBuffer                                            ; Clear the updateBuffer Variable                               
 C0A8  1803082F0875      movw    #buffer, pointer                                        ; Stores the First Address of buffer into pointer
 C0AE  180308370877      movw    #updateBuffer, updatePointer            ; Stores the First Address of updateBuffer into updatePointer
 C0B4  180B00084D        movb    #$00, RUN                                       ; Motor stop at Intialization
 C0B9  180300190806     movw     #$0019, V_Ref                                   ; Set Initial V_Ref value $19=25
 C0BF  180304000814     movw     #$0400, Ki                                      ; Set Initial Ki value $400=1024=1024(1)
 C0C5  180304000816      movw    #$0400, oldKi                                           ; Set Initial Ki value $400=1024=1024(1)
 C0CB  180314000818     movw     #$1400, Kp                                      ; Set Initial Kp value $1400=5120=1024(5)
 C0D1  180B010850        movb    #$01, autoManualFlag                            ; Set the AutoManualFlag to Auto
 C0D6  180B010800        movb    #$01, mmState                                           ; Set the Mastermind State Variable to 1    
 C0DB  3D                rts                                                                                     ; Return to Main
 C0DC            
 C0DC            ;====  Mastermind State 1 - Splash Screen and Setting Displays Flags & Counters  =========
 C0DC            
 C0DC            mmstate1:
 C0DC            
 C0DC  180B010849        movb   #$01, firstChar                                  ; Set firstChar to 1 (True) 
 C0E1  180B010852     movb   #$01, VRefFlag                                              ; Set VRefFlag to 1 (True) 
 C0E6  180B010856        movb   #$01, KiFlag                                             ; Set KiFlag to 1 (True) 
 C0EB  180B010857        movb   #$01, KpFlag                                             ; Set KpFlag to 1 (True) 
 C0F0  180B010853        movb   #$01, VActFlag                                           ; Set VActFlag to 1 (True) 
 C0F5  180B010855        movb   #$01, errorFlag                                          ; Set errorFlag to 1 (True) 
 C0FA  180B010854        movb   #$01, effortFlag                                         ; Set VRefFlag to 1 (True) 
 C0FF  180B010860        movb   #$01, offPrintFlag                                       ; Set offPrintFlag to 1 (True) 
 C104  180B010862        movb   #$01, closedLoopPrintFlag                        ; Set closedLoopPrintFlag to 1 (True) 
 C109  180B010863        movb   #$01, autoPrintFlag                                      ; Set autoPrintFlag to 1 (True) 
 C10E  180B01086D        movb   #$01, updateValuesFlag                           ; Set updateValuesFlag to 1 (True) 
 C113  180B020800        movb   #$02, mmState                                            ; Set the Mastermind State Variable to 2 (Hub)
 C118  3D                rts                                                                             ; Return to Main
 C119            
 C119            ;===============  Mastermind State 2 - Hub  ============================
 C119            
 C119            mmstate2:
 C119            
 C119  F70846            tst     keyFlag                      ; Test keyFlag
 C11C  18270043          lbeq    NO_KEY                       ; If keyFlag is False, Branch to NO_KEY
 C120  790846            clr     keyFlag                      ; Clear keyFlag
 C123  C1F1              cmpb    #$F1                         ; Compare Acc. B to Hex Value of 'F1'
 C125  18270063          lbeq    F1_TRUE                      ; If B = '$F1', Branch to F1_TRUE
 C129  C1F2              cmpb    #$F2                         ; Compare Acc. B to Hex Value of 'F2'
 C12B  18270087          lbeq    F2_TRUE                      ; If B = '$F2', Branch to F2_TRUE
 C12F  C108              cmpb    #$08                         ; Compare Acc. B to Hex Value of '08'
 C131  182700AB          lbeq    BS_TRUE                      ; If B = '$08', Branch to BS_TRUE
 C135  C141              cmpb    #$41                         ; Compare Acc. B to Hex Value of 'F1'
 C137  182700B7          lbeq    A_TRUE                                           ; If B = '$41', Branch to ENT_TRUE
 C13B  C142              cmpb    #$42                         ; Compare Acc. B to Hex Value of 'F1'
 C13D  182700BC          lbeq    B_TRUE                                           ; If B = '$41', Branch to ENT_TRUE
 C141  C143              cmpb    #$43                         ; Compare Acc. B to Hex Value of 'F1'
 C143  182700C1          lbeq    C_TRUE                                           ; If B = '$41', Branch to ENT_TRUE
 C147  C144              cmpb    #$44                         ; Compare Acc. B to Hex Value of 'F1'
 C149  182700CB          lbeq    D_TRUE                                           ; If B = '$41', Branch to ENT_TRUE
 C14D  C145              cmpb    #$45                         ; Compare Acc. B to Hex Value of 'F1'
 C14F  182700D5          lbeq    E_TRUE                                           ; If B = '$41', Branch to ENT_TRUE
 C153  C146              cmpb    #$46                         ; Compare Acc. B to Hex Value of 'F1'
 C155  182700DF          lbeq    F_TRUE                                           ; If B = '$41', Branch to ENT_TRUE
 C159  C10A              cmpb    #$0A                         ; Compare Acc. B to Hex Value of '0A'
 C15B  18270087          lbeq    ENT_TRUE                     ; If B = '$0A', Branch to ENT_TRUE
 C15F  18200089          lbra    DIGIT_TRUE                   ; Otherwise Branch to DIGIT_TRUE
 C163            
 C163            NO_KEY:
 C163            
 C163  F7084A            tst             backspaceFlag                ; Test backspaceFlag
 C166  182600D9          lbne    BACKSPACE_GO                 ; If backspaceFlag Not 0 (False), Branch to BACKSPACE_GO
 C16A  F70848            tst             enterFlag                    ; Test enterFlag
 C16D  182600D8          lbne    ENTER_GO                     ; If enterFlag Not 0 (False), Branch to ENTER_GO
 C171  F7084B            tst             digitFlag                    ; Test digitFlag
 C174  182600D7          lbne    DIGIT_GO                     ; If digitFlag Not 0 (False), Branch to DIGIT_GO
 C178  F7084C            tst             charFlag                     ; Test charFlag
 C17B  182600D9          lbne    CHAR_GO                      ; If charFlag Not 0 (False), Branch to CHAR_GO
 C17F  F7086D            tst             updateValuesFlag                         ; Test updateValuesFlag
 C182  182600DB          lbne    UPDATE_VALUES_GO                         ; If updateValuesFlag Not $00, Branch to UPDATE_VALUES_GO
 C186  180B020800        movb    #$02, mmState                ; If No Key was Pressed, Return to Hub
 C18B  3D                rts                                                                      ; Return to Main
 C18C                    
 C18C            F1_TRUE:
 C18C            
 C18C  F70870        tst         promptUpFlag
 C18F  271F              beq             F1_DONE
 C191  F7086C            tst             VRefSignFlag                             ; Test VRefSignFlag
 C194  261A              bne             F1_DONE                                          ; If VRefSignFlag is 0 (False), Branch to F1_DONE
 C196  F70843            tst             digitCounter                             ; Test digitCounter
 C199  2615              bne             F1_DONE                                          ; If digitCounter is 0 (False), Branch to F1_DONE
 C19B  180B010866        movb    #$01, VRefPosPrintFlag           ; Set VRefPosPrintFlag to 1 (True)
 C1A0  180B000871        movb    #$00, VRefSign                           ; Set VRefSign to 0 (False)
 C1A5  180B010847        movb    #$01, echoFlag                           ; Set echoFlag to 1 (True)
 C1AA  180B020800        movb    #$02, mmState                ; Set the Mastermind State Variable to 2 (Hub)
 C1AF  3D                rts                                                                      ; Return to Main
 C1B0            
 C1B0            F1_DONE:
 C1B0            	
 C1B0  180B020800        movb    #$02, mmState                ; Set the Mastermind State Variable to 2 (Hub)
 C1B5  3D                rts                                                                      ; Return to Main
 C1B6                            
 C1B6            F2_TRUE:
 C1B6            
 C1B6  F70870        tst         promptUpFlag
 C1B9  271F              beq             F2_DONE
 C1BB  F7086C            tst             VRefSignFlag                             ; Test VRefSignFlag
 C1BE  261A              bne             F2_DONE                                          ; If VRefSignFlag is 0 (False), Branch to F2_DONE
 C1C0  F70843            tst             digitCounter                             ; Test digitCounter
 C1C3  2615              bne             F2_DONE                                          ; If digitCounter is 0 (False), Branch to F2_DONE
 C1C5  180B010865        movb    #$01, VRefNegPrintFlag           ; Set VRefPosPrintFlag to 1 (True)
 C1CA  180B010871        movb    #$01, VRefSign                           ; Set VRefSign to 0 (False)
 C1CF  180B010847        movb    #$01, echoFlag                           ; Set echoFlag to 1 (True)
 C1D4  180B020800        movb    #$02, mmState                ; Set the Mastermind State Variable to 2 (Hub) 
 C1D9  3D                rts                                                                      ; Return to Main
 C1DA            
 C1DA            F2_DONE:
 C1DA            	
 C1DA  180B020800        movb    #$02, mmState                ; Set the Mastermind State Variable to 2 (Hub) 
 C1DF  3D                rts                                                                      ; Return to Main
 C1E0            
 C1E0            BS_TRUE:
 C1E0            	
 C1E0  180B01084A        movb    #$01, backspaceFlag          ; Set backspaceFlag to 1 (True)
 C1E5  3D                rts                                                                      ; Return to Main
 C1E6                    
 C1E6            ENT_TRUE:
 C1E6            	
 C1E6  180B010848        movb    #$01, enterFlag              ; Set enterFlag to 1 (True)
 C1EB  3D                rts                                                                      ; Return to Main
 C1EC            
 C1EC            DIGIT_TRUE:
 C1EC            		   
 C1EC  180B01084B        movb    #$01, digitFlag              ; Set digitFlag to 1 (True)
 C1F1  3D                rts                                                                      ; Return to Main
 C1F2            
 C1F2            A_TRUE:
 C1F2            
 C1F2  180B01084C        movb    #$01, charFlag                           ; Set charFlag to 1 (True)
 C1F7  180B010858        movb    #$01, AFlag                                      ; Set AFlag to 1 (True)
 C1FC  3D                rts                                                                      ; Return to Main
 C1FD                    
 C1FD            B_TRUE:
 C1FD            
 C1FD  180B01084C        movb    #$01, charFlag                           ; Set charFlag to 1 (True)
 C202  180B010859        movb    #$01, BFlag                                      ; Set BFlag to 1 (True)
 C207  3D                rts                                                                      ; Return to Main
 C208                    
 C208            C_TRUE:
 C208            
 C208  180B01084C        movb    #$01, charFlag                           ; Set charFlag to 1 (True)
 C20D  180B01085A        movb    #$01, CFlag                                      ; Set CFlag to 1 (True)
 C212  180B010870        movb    #$01, promptUpFlag                       ; Set promptUpFlag to 1 (True)
 C217  3D                rts                                                                      ; Return to Main
 C218                    
 C218            D_TRUE:
 C218            
 C218  180B01084C        movb    #$01, charFlag                           ; Set charFlag to 1 (True)
 C21D  180B01085B        movb    #$01, DFlag                                      ; Set DFlag to 1 (True)
 C222  180B010870        movb    #$01, promptUpFlag                       ; Set promptUpFlag to 1 (True)
 C227  3D                rts                                                                      ; Return to Main
 C228                    
 C228            E_TRUE:
 C228            
 C228  180B01084C        movb    #$01, charFlag                           ; Set charFlag to 1 (True)
 C22D  180B01085C        movb    #$01, EFlag                                      ; Set EFlag to 1 (True)
 C232  180B010870        movb    #$01, promptUpFlag                       ; Set promptUpFlag to 1 (True)
 C237  3D                rts                                                                      ; Return to Main
 C238            
 C238            F_TRUE:
 C238            
 C238  180B01084C        movb    #$01, charFlag                           ; Set charFlag to 1 (True)
 C23D  180B01085D        movb    #$01, FFlag                                      ; Set EFlag to 1 (True)
 C242  3D                rts                                                                      ; Return to Main
 C243                    
 C243                    
 C243            BACKSPACE_GO:
 C243            
 C243  180B030800        movb    #$03, mmState                ; Set next Mastermind State (mmstate) to Backspace
 C248  3D                rts                                                                      ; Return to Main
 C249                    
 C249            ENTER_GO:
 C249            
 C249  180B040800        movb    #$04, mmState                ; Set next Mastermind State (mmstate) to Enter
 C24E  3D                rts                                                                      ; Return to Main
 C24F                            
 C24F            DIGIT_GO:
 C24F            	
 C24F  79084B            clr     digitFlag                                        ; Clear the digitFlag
 C252  180B050800        movb    #$05, mmState                ; Set next Mastermind State (mmstate) to Digit
 C257  3D                rts                                                                      ; Return to Main
 C258                    
 C258            CHAR_GO:
 C258            
 C258  79084C        clr         charFlag                                         ; Clear the charFlag
 C25B  180B060800        movb    #$06, mmState                ; Set next Mastermind State (mmstate) to Character
 C260  3D                rts                                                                      ; Return to Main
 C261            
 C261            UPDATE_VALUES_GO:
 C261            
 C261  79086D        clr         updateValuesFlag                         ; Clear the updateValuesFlag
 C264  180B070800        movb    #$07, mmState                ; Set next Mastermind State (mmstate) to Update Values
 C269  3D                rts                                                                      ; Return to Main
 C26A            
 C26A                    
 C26A            ;===================== Mastermind State 3 - Backspace State ====================
 C26A            
 C26A            mmstate3:
 C26A            
 C26A  F7086C            tst     VRefSignFlag                             ; Test the VRefSignFlag
 C26D  260C              bne     BACKSPACE_SIGN                           ; If VRefSignFlag is 1 (True), Branch to BACKSPACE_SIGN
 C26F  F70843            tst     digitCounter                 ; Test digitCounter
 C272  2718              beq     BACKSPACE_DONE               ; If digitCounter is 0, Branch to BSPACE_DONE
 C274  F7084A            tst     backspaceFlag                ; Test backspaceFlag
 C277  2713              beq     BACKSPACE_DONE               ; If backspaceFlag is 0 (False), Branch to BSPACE_DONE
 C279  200B              bra     BACKSPACE_SET                            ; Branch Always to BACKSPACE_SET
 C27B            
 C27B            BACKSPACE_SIGN:
 C27B            
 C27B  180B00086C     movb       #$00, VRefSignFlag                       ; Set VRefSignFlag to 0 (False)
 C280  180B010867     movb       #$01, backspacePrint             ; Set backspacePrint to 1 (True)
 C285  3D            rts                                                                  ; Return to Main
 C286            
 C286            BACKSPACE_SET:
 C286            
 C286  180B010867        movb    #$01, backspacePrint         ; Set backspacePrint to 1 (True)
 C28B  3D                rts                                                                      ; Return to Main       
 C28C                    
 C28C            BACKSPACE_DONE:
 C28C            
 C28C  180B00084A        movb    #$00, backspaceFlag                      ; Set backspaceFlag to 1 (True)
 C291  180B020800        movb    #$02, mmState                ; Set the Mastermind State Variable to 2 (Hub)
 C296  3D                rts                                                                  ; Return to Main
 C297            
 C297            ;===================== Mastermind State 4 - Enter State ========================
 C297            
 C297            mmstate4:
 C297            
 C297  F70848            tst             enterFlag                                        ; Test the enterFlag
 C29A  2604              bne             ENTER_INIT                                       ; If enterFlag is 1 (True), Branch to ENTER_INIT
 C29C  182700DE          lbeq    ENTER_DONE                                       ; If enterFlag is 0 (False), Branch to ENTER_DONE
 C2A0                            
 C2A0            ENTER_INIT:
 C2A0            		
 C2A0  F70843            tst     digitCounter                  ; Test digitCounter
 C2A3  18270056          lbeq    EMPTY_VALUE                   ; If digitCounter is 0 (False), Branch to EMPTY_VALUE
 C2A7  2000              bra     ASCII_BCD                     ; Otherwise Branch to ASCII_BCD
 C2A9            
 C2A9            ASCII_BCD:
 C2A9            
 C2A9  1803082F0875      movw    #buffer, pointer              ; Load First Address of buffer into pointer
 C2AF  180300000835      movw    #$0000, result                ; Clear the Value of result
 C2B5                            
 C2B5            	LOOP:
 C2B5            
 C2B5  CD000A                    ldy     #$0A                      ; Load Accumulator A with 10    
 C2B8  FC0835                    ldd     result                    ; Load Accumulator B with result    
 C2BB  13                        emul                              ; Multiply A and B, Store in A:B or D
 C2BC  8D0000                    cmpy    #$0000                    ; Compare Accumulator D with 0 
 C2BF  2634                      bne     TOO_BIG_VALUE             ; If a Carry Present in Y, Branch to TOO_BIG_VALUE
 C2C1  7C0835                    std     result                    ; Store Accumulator D into result    
 C2C4  FE0875                    ldx     pointer                   ; Load X with buffer Address Stored In pointer    
 C2C7  E600                      ldab    0,x                       ; Load Accumulator B with the Contents in X  
 C2C9  C030                      subb    #$30                      ; Subtract 30 From Accumulator B  
 C2CB  87                        clra                              ; Clear Accumulator A 
 C2CC  F30835                    addd    result                    ; Add result To B and Store Back Into B
 C2CF  2924                      bvs     TOO_BIG_VALUE                 ; If greater than 32767 hex, Branch to TOO_BIG_VALUE  
 C2D1  7C0835                    std     result                    ; Store D in result 
 C2D4  730843                    dec     digitCounter              ; Decrement digitCounter
 C2D7  F70843                    tst             digitCounter              ; Test digitCounter         
 C2DA  2706                      beq     VALUE_PUSH_MAIN           ; If digitCounter is zero, Branch to VALUE_PUSH_MAIN        
 C2DC  08                        inx                               ; Increment Address in X
 C2DD  7E0875                    stx             pointer                   ; Store Address In X Into Pointer
 C2E0  20D3                      bra     LOOP                      ; Branch Back Into LOOP               
 C2E2                    
 C2E2            VALUE_PUSH_MAIN:
 C2E2            
 C2E2  F70852        tst         VRefFlag                                          ; Test VRefFlag
 C2E5  262B              bne             VREF_STORE                                        ; If VRefFlag is 1 (True), Branch to VREF_STORE
 C2E7  F70856            tst             KiFlag                                            ; Test KiFlag
 C2EA  2648              bne             KI_STORE                                          ; If KiFlag is 1 (True), Branch to KI_STORE
 C2EC  F70857            tst             KpFlag                                            ; Test KpFlag
 C2EF  266B              bne     KP_STORE                                          ; If KpFlag is 1 (True), Branch to KP_STORE
 C2F1  18200089          lbra    ENTER_DONE                    ; Otherwise Branch To ENTER_DONE
 C2F5                    
 C2F5            TOO_BIG_VALUE:
 C2F5            
 C2F5  18037FFF0835      movw     #$7FFF, result                           ; Load $7FFF (32767) to result
 C2FB  20E5              bra              VALUE_PUSH_MAIN                          ; Branch Always to VALUE_PUSH_MAIN
 C2FD                            
 C2FD            EMPTY_VALUE:
 C2FD            	
 C2FD  180300000835      movw    #$0000, result                ; Clear the Value of result
 C303  1803082F0875      movw    #buffer, pointer              ; Move The First Address of buffer into Pointer
 C309  790843            clr         digitCounter                  ; Clear the digitCounter
 C30C  180B000848        movb    #$00, enterFlag               ; Set enterFlag to 1 (True)
 C311  3D                rts                                           ; Return to Main
 C312            
 C312            VREF_STORE:
 C312            
 C312  F70871        tst    VRefSign                                               ; Test VRefSign
 C315  260D              bne        VREF_NEG_STORE                 ; If VRefFlag is 1 (Negative), Branch to VREF_NEG_STORE
 C317  180408350806      movw   result, V_Ref                              ; Move the Value of result into V_Ref
 C31D  180B010852        movb   #$01, VRefFlag                             ; Set VRefFlag to 1 (True)
 C322  205A              bra        ENTER_DONE                                     ; Branch Always to ENTER_DONE
 C324            
 C324            VREF_NEG_STORE:
 C324            
 C324  CC0000        ldd     #$0000                                ; Load D with $0000 (0)
 C327  B30835        subd    result                                ; Subracting result from $0000 (0) to Return Neg Value
 C32A  7C0806            std     V_Ref                                             ; Storing D into V_Ref
 C32D  180B010852        movb    #$01, VRefFlag                            ; Set VRefFlag to 1 (True)
 C332  204A              bra             ENTER_DONE                                        ; Branch Always to ENTER_DONE
 C334                    
 C334            KI_STORE: ; MIGHT BE REDUNDANT SO WE NEED TO TEST
 C334            
 C334  CE7FFF        ldx     #$7FFF                                                ; Load X with $7FFF (32767)
 C337  BE0835        cpx         result                                            ; Compare X with the Value of result
 C33A  2A0D          bpl     NO_KI_SATURATION                      ; If result is Less Than $7FFF (32767), Branch to NO_KI_SATURATION
 C33C  18037FFF0814      movw    #$7FFF, Ki                                        ; Storing $7FFF (32767) into Ki
 C342  180B010856        movb    #$01, KiFlag                              ; Set KiFlag to 1 (True)       
 C347  2035              bra             ENTER_DONE                                        ; Branch Always to ENTER_DONE
 C349            
 C349            NO_KI_SATURATION:
 C349            
 C349  180408350814      movw    result, Ki                                        ; Move the Value in result into Ki
 C34F  180408350816      movw    result, oldKi                             ; Move the Value in result into oldKi
 C355  180B010856        movb    #$01, KiFlag                              ; Set KiFlag to 1 (True)
 C35A  2022              bra     ENTER_DONE                                        ; Branch Always to ENTER_DONE
 C35C            
 C35C            KP_STORE: ; MIGHT BE REDUNDANT SO WE NEED TO TEST
 C35C                
 C35C  CE7FFF        ldx     #$7FFF                                                ; Load X with $7FFF (32767)
 C35F  BE0835        cpx     result                                                ; Compare X with the Value of result
 C362  2A0D          bpl     NO_KP_SATURATION                      ; If result is Less Than $7FFF (32767), Branch to NO_KP_SATURATION
 C364  18037FFF0818      movw    #$7fff, Kp                                        ; Storing $7FFF (32767) into Kp
 C36A  180B010857        movb    #$01, KpFlag                              ; Set KpFlag to 1 (True)
 C36F  200D              bra             ENTER_DONE                                ; Branch Always to ENTER_DONE
 C371                    
 C371            NO_KP_SATURATION:
 C371            
 C371  180408350818      movw    result, Kp                                    ; Move the Value in result into Kp
 C377  180B010857        movb    #$01, KpFlag                              ; Set KpFlag to 1 (True)
 C37C  2000          bra         ENTER_DONE                                        ; Branch Always to ENTER_DONE
 C37E            
 C37E            ENTER_DONE:
 C37E            
 C37E  180300000835      movw    #$0000, result                ; Clear the Value of result
 C384  790843            clr         digitCounter                  ; Clear the digitCounter
 C387  1803082F0875      movw    #buffer, pointer              ; Move the First Address of buffer into pointer
 C38D  180B000848        movb    #$00, enterFlag               ; Set KpFlag to 1 (True)
 C392  180B00086B        movb    #$00, digitAllowed                        ; Set digitAllowed to 1 (True)
 C397  180B000870        movb    #$00, promptUpFlag                        ; Set promptUpFlag to 1 (True)                   
 C39C  180B01086D        movb    #$01, updateValuesFlag            ; Set updateValuesFlag to 1 (True)    
 C3A1  180B01086F        movb    #$01, updateLine2Flag             ; Set KpFlag to 1 (True)
 C3A6  180B010851        movb    #$01, LCDUpdateFlag                       ; Set KpFlag to 1 (True)
 C3AB  180B01086D        movb    #$01, updateValuesFlag            ; Set KpFlag to 1 (True)
 C3B0  180B000870        movb    #$00, promptUpFlag                        ; Set KpFlag to 1 (True)
 C3B5  180B00086C        movb    #$00, VRefSignFlag                        ; Set KpFlag to 1 (True)
 C3BA  180B020800        movb    #$02, mmState                             ; Set the Mastermind State Variable to 2 (Hub)                                      
 C3BF  3D                rts 
 C3C0            
 C3C0            ;====================  Mastermind State 5 - Digit Entered   ====================
 C3C0            
 C3C0            mmstate5:
 C3C0            
 C3C0  F7086B            tst             digitAllowed                              ; Test digitAllowed
 C3C3  18270029          lbeq    DIGIT_DONE                                        ; If digitAllowed is 0 (Not Allowed), Branch to DIGIT_DONE
 C3C7  F7084B            tst             digitFlag                                         ; Test digitFlag
 C3CA  261C              bne             DIGIT_WAIT                                        ; If digitAllowed is 1 (True), Branch to DIGIT_WAIT
 C3CC  C141              cmpb    #$41                                      ; Compare Hexadecimal Value In B to $41
 C3CE  18250002          lblo    DIGIT                                     ; If Value in B < $40, Branch to DIGIT
 C3D2  2009              bra             NOTDIGIT                                  ; Otherwise Value in B is not a Digit, Branch to NOTDIGIT
 C3D4              
 C3D4            DIGIT:
 C3D4            
 C3D4  180B01084B        movb    #$01, digitFlag                           ; Set KpFlag to 1 (True)
 C3D9  18200409          lbra    BUFFER_STORE                  ; Branch Always BUFFER_STORE
 C3DD            
 C3DD            NOTDIGIT:
 C3DD            
 C3DD  180B000846        movb    #$00, keyFlag                 ; Set KpFlag to 0 (False)
 C3E2  180B020800        movb    #$02, mmState                             ; Set the Mastermind State Variable to 2 (Hub)
 C3E7  3D                rts                                                                       ; Return to Main
 C3E8            
 C3E8            DIGIT_WAIT:
 C3E8            
 C3E8  F70847            tst     echoFlag                                          ; Set KpFlag to 0 (False)
 C3EB  18270001          lbeq    DIGIT_DONE                                    ; If echoFlag is 0 (False), Branch to DIGIT_DONE
 C3EF  3D                rts                                                                       ; Return to Main
 C3F0                    
 C3F0            DIGIT_DONE:
 C3F0            
 C3F0  180B00084B     movb       #$00, digitFlag                           ; Set digitFlag to 0 (False)
 C3F5  180B020800        movb    #$02, mmState                 ; Set the Mastermind State Variable to 2 (Hub)
 C3FA  3D                rts                                                               ; Return to Main
 C3FB            
 C3FB            ;===================== Mastermind State 6 - Character Entered ==================
 C3FB            
 C3FB            mmstate6:
 C3FB            
 C3FB  F70852        tst         VRefFlag                                          ; Test VRefFlag
 C3FE  18260172          lbne    VALUE_CHAR_DONE                           ; If VRefFlag is 1 (True), Branch to VALUE_CHAR_DONE
 C402  F70856            tst     KiFlag                                            ; Test KiFlag
 C405  1826016B          lbne    VALUE_CHAR_DONE                           ; If KiFlag is 1 (True), Branch to VALUE_CHAR_DONE
 C409  F70857            tst     KpFlag                                            ; Test KpFlag
 C40C  18260164          lbne    VALUE_CHAR_DONE                           ; If KpFlag is 1 (True), Branch to VALUE_CHAR_DONE
 C410  F70858            tst     AFlag                                             ; Test AFlag
 C413  18260029          lbne    AFLAG_GO                                          ; If AFlag is 1 (True), Branch to AFLAG_GO
 C417  F70859            tst     BFlag                                             ; Test BFlag
 C41A  1826005D          lbne    BFLAG_GO                                          ; If BFlag is 1 (True), Branch to BFLAG_GO            
 C41E  F7085A            tst     CFlag                                             ; Test CFlag
 C421  182600B2          lbne    CFLAG_GO                                          ; If CFlag is 1 (True), Branch to CFLAG_GO
 C425  F7085B            tst     DFlag                                             ; Test DFlag
 C428  182600BE          lbne    DFLAG_GO                                          ; If DFlag is 1 (True), Branch to DFLAG_GO
 C42C  F7085C            tst     EFlag                                             ; Test EFlag
 C42F  182600D9          lbne    EFLAG_GO                                      ; If EFlag is 1 (True), Branch to EFLAG_GO
 C433  F7085D            tst     FFlag                                             ; Test FFlag
 C436  182600F4          lbne    FFLAG_GO                                          ; If FFlag is 1 (True), Branch to FFLAG_GO
 C43A  180B020800        movb    #$02, mmState                             ; Set the Mastermind State Variable to 2 (Hub)
 C43F  3D                rts                                                               ; Return to Main                              
 C440                    
 C440            AFLAG_GO:
 C440            
 C440  F7084D        tst         RUN                                                       ; Test RUN
 C443  18260004          lbne    MOTOR_OFF                                         ; If RUN is 1 (Off), Branch to MOTOR_OFF
 C447  18200018          lbra    MOTOR_ON                                          ; Branch Always to MOTOR_ON
 C44B                    
 C44B            MOTOR_OFF:
 C44B            	
 C44B  180B00084D        movb    #$00, RUN                                         ; Set RUN to 0 (False)
 C450  180B010860        movb    #$01, offPrintFlag                        ; Set offPrintFlag to 1 (True)
 C455  180B00085F        movb    #$00, onPrintFlag                         ; Set onPrintFlag to 0 (False)
 C45A  180B000858        movb    #$00, AFlag                                       ; Set AFlag to 0 (False)
 C45F  18200106          lbra    STATE_CHAR_DONE                           ; Branch Always to STATE_CHAR_DONE
 C463                    
 C463            MOTOR_ON:
 C463            	
 C463  180B01084D        movb    #$01, RUN                                         ; Set RUN to 1 (True)
 C468  180B000860        movb    #$00, offPrintFlag                        ; Set offPrintFlag to 0 (False)
 C46D  180B01085F        movb    #$01, onPrintFlag                         ; Set onPrintFlag to 1 (True)
 C472  180B000858        movb    #$00, AFlag                                   ; Set AFlag to 0 (False)
 C477  182000EE          lbra    STATE_CHAR_DONE                           ; Branch Always to STATE_CHAR_DONE
 C47B                    
 C47B            BFLAG_GO:
 C47B            
 C47B  F7084E        tst         loopSetFlag                                       ; Test loopSetFlag
 C47E  18270004          lbeq    OPEN_LOOP_SET                             ; If loopSetFlag is 0 (Next State - Open), Branch to OPEN_LOOP_SET 
 C482  1826002E          lbne    CLOSED_LOOP_SET                           ; If loopSetFlag is 1 (Next State - Closed), Branch to CLOSED_LOOP_SET
 C486                    
 C486            OPEN_LOOP_SET:
 C486            
 C486  180B000862        movb    #$00, closedLoopPrintFlag         ; Set closedLoopPrintFlag to 0 (False)
 C48B  180B010861        movb    #$01, openLoopPrintFlag           ; Set openLoopPrintFlag to 1 (True)
 C490  180B01084E        movb    #$01, loopSetFlag                         ; Set loopSetFlag to 1 (Next State - Closed)
 C495  180B000859        movb    #$00, BFlag                                       ; Set BFlag to 0 (False)
 C49A  180B01085E        movb    #$01, firstKiFlag
 C49F  180408140816      movw    Ki, oldKi
 C4A5  180300000814      movw    #$0000, Ki
 C4AB  180B010856        movb    #$01, KiFlag
 C4B0  182000B5          lbra    STATE_CHAR_DONE                           ; Branch Always to STATE_CHAR_DONE
 C4B4                    
 C4B4            CLOSED_LOOP_SET:
 C4B4            
 C4B4  180B010862        movb    #$01, closedLoopPrintFlag         ; Set closedLoopPrintFlag to 1 (True)          
 C4B9  180B000861        movb    #$00, openLoopPrintFlag           ; Set openLoopPrintFlag to 0 (False)
 C4BE  180B00084E        movb    #$00, loopSetFlag                         ; Set loopSetFlag to 1 (Next State - Open)
 C4C3  180B000859        movb    #$00, BFlag                                       ; Set BFlag to 0 (False)
 C4C8  180408160814      movw    oldKi, Ki
 C4CE  180B010856        movb    #$01, KiFlag
 C4D3  18200092          lbra    STATE_CHAR_DONE                           ; Branch Always to STATE_CHAR_DONE            
 C4D7                            
 C4D7            CFLAG_GO:
 C4D7            
 C4D7  180B010852        movb    #$01, VRefFlag                            ; Set VRefFlag to 1 (True) 
 C4DC  180B010868        movb    #$01, VRefPromptFlag              ; Set VRefPromptFlag to 1 (True)
 C4E1  180B00085A        movb    #$00, CFlag                                       ; Set CFlag to 0 (False)
 C4E6  1820008A          lbra    VALUE_CHAR_DONE                           ; Branch Always to VALUE_CHAR_DONE    
 C4EA                            
 C4EA            DFLAG_GO:
 C4EA            	
 C4EA  180B00084D        movb    #$00, RUN                                         ; Set RUN to 0 (Stop) 
 C4EF  180B010860        movb    #$01, offPrintFlag                        ; Set offPrintValue to 1 (True)  
 C4F4  180B01084F        movb    #$01, stateVariableFlag           ; Set stateVariableFlag to 1 (True) 
 C4F9  180B010856        movb    #$01, KiFlag                              ; Set KiFlag to 1 (True) 
 C4FE  180B010869        movb    #$01, KiPromptFlag                        ; Set KiPromptFlag to 1 (True) 
 C503  180B00085B        movb    #$00, DFlag                                       ; Set DFlag to 0 (False) 
 C508  18200068          lbra    VALUE_CHAR_DONE                           ; Branch Always to VALUE_CHAR_DONE
 C50C            
 C50C            EFLAG_GO:
 C50C            
 C50C  180B00084D        movb    #$00, RUN                                         ; Set RUN to 0 (Stop)                                         
 C511  180B010860        movb    #$01, offPrintFlag                        ; Set offPrintValue to 1 (True)
 C516  180B01084F        movb    #$01, stateVariableFlag           ; Set stateVariableFlag to 1 (True)
 C51B  180B010857        movb    #$01, KpFlag                              ; Set KpFlag to 1 (True)
 C520  180B01086A        movb    #$01, KpPromptFlag                        ; Set KpPromptFlag to 1 (True) 
 C525  180B00085C        movb    #$00, EFlag                                       ; Set EFlag to 0 (False) 
 C52A  1820003B          lbra    STATE_CHAR_DONE                           ; Branch Always to STATE_CHAR_DONE    
 C52E            
 C52E            FFLAG_GO:
 C52E            
 C52E  F70850        tst   autoManualFlag                                  ; Test autoManualFlag 
 C531  18270004          lbeq   AUTO_SET                                           ; If autoManualFlag is 0 (Next State - Auto), Branch to AUTO_SET
 C535  18260018          lbne   MANUAL_SET                                         ; If autoManualFlag is 1 (Next State - Manual), Branch to MANUAL_SET
 C539                    
 C539            AUTO_SET:
 C539            
 C539  180B010863        movb   #$01, autoPrintFlag                        ; Set autoPrintFlag to 1 (True)                 
 C53E  180B000864        movb   #$00, manualPrintFlag              ; Set manualPrintFlag to 0 (False) 
 C543  180B010850        movb   #$01, autoManualFlag                       ; Set autoManualFlag to 1 (Auto) 
 C548  180B00085D        movb   #$00, FFlag                                        ; Set FFlag to 0 (False) 
 C54D  18200018          lbra   STATE_CHAR_DONE                        ; Branch Always to STATE_CHAR_DONE
 C551            
 C551            MANUAL_SET:
 C551            
 C551  180B000863        movb   #$00, autoPrintFlag                        ; Set autoPrintFlag to 0 (False)
 C556  180B010864        movb   #$01, manualPrintFlag              ; Set manualPrintFlag to 1 (True)     
 C55B  180B000850        movb   #$00, autoManualFlag                       ; Set autoManualFlag to 1 (Manual)
 C560  180B00085D        movb   #$00, FFlag                                        ; Set FFlag to 0 (False) 
 C565  18200000          lbra   STATE_CHAR_DONE                        ; Branch Always to STATE_CHAR_DONE        
 C569            
 C569            STATE_CHAR_DONE:
 C569            
 C569  180B01084F        movb   #$01, stateVariableFlag            ; Set stateVariableFlag to 0 (True)
 C56E  180B020800        movb   #$02,    mmState                           ; Set the Mastermind State Variable to 2 (Hub)
 C573  3D                rts                                                                       ; Return to Main
 C574                    
 C574            VALUE_CHAR_DONE:
 C574            
 C574  180B020800        movb   #$02,    mmState                           ; Set the Mastermind State Variable to 2 (Hub)
 C579  3D                rts                                                                       ; Return to Main
 C57A            
 C57A            ;===================== Mastermind State 7 - Update Values ======================
 C57A            
 C57A            mmstate7:
 C57A            
 C57A  7B083E            stab   stateVariable     
 C57D  F70870        tst    promptUpFlag                                   ; Test promptUpFlag 
 C580  18260254          lbne   UPDATE_BUFFER_EXIT                 ; If promptUpFlag is 1 (True), Branch to UPDATE_BUFFER_EXIT
 C584  F70852            tst    VRefFlag                                           ; Test VRefFlag
 C587  18260029          lbne   UPDATE_VREF                                        ; If VRefFlag is 1 (True), Branch to UPDATE_VREF
 C58B  F70856            tst    KiFlag                                             ; Test KiFlag
 C58E  18260046          lbne   UPDATE_KI                                          ; If KiFlag is 1 (True), Branch to UPDATE_KI
 C592  F70857            tst    KpFlag                                             ; Test KpFlag
 C595  18260044          lbne   UPDATE_KP                                          ; If KiFlag is 1 (True), Branch to UPDATE_KI
 C599  F70853            tst    VActFlag                                           ; Test VActFlag
 C59C  18260026          lbne   UPDATE_VACT                                        ; If VActFlag is 1 (True), Branch to UPDATE_VACT
 C5A0  F70855            tst    errorFlag                                          ; Test errorFlag
 C5A3  1826003B          lbne   UPDATE_ERROR                                       ; If errorFlag is 1 (True), Branch to UPDATE_ERROR
 C5A7  F70854            tst    effortFlag                                         ; Test effortFlag
 C5AA  18260046          lbne   UPDATE_EFFORT                              ; If effortFlag is 1 (True), Branch to UPDATE_EFFORT
 C5AE  180B020800        movb   #$02, mmState                              ; Set the Mastermind State Variable to 2 (Hub)
 C5B3  3D                rts                                                                       ; Return to Main
 C5B4            
 C5B4            UPDATE_VREF:
 C5B4            	
 C5B4  F70871            tst     VRefSign                                          ; Test VRefSign                  
 C5B7  2605              bne     NEGATIVE_VREF                             ; If VRefSign is 1 (Negative), Branch to NEGATIVE_VREF
 C5B9  FC0806        ldd         V_Ref                                             ; Load Accumulator D with V_Ref
 C5BC  2048          bra         BINARY_ASCII                      ; Branch Always to BINARY_ASCII
 C5BE            
 C5BE            NEGATIVE_VREF:
 C5BE            	   
 C5BE  CC0000        ldd         #$0000                                            ; Load Accumulator D with $0000 (0)            
 C5C1  B30806        subd        V_Ref                             ; Subtract V_Ref from $0000 (0) to Get V_Ref to Convert 
 C5C4  2040          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII 
 C5C6            
 C5C6            UPDATE_VACT:
 C5C6            	
 C5C6  F70872            tst     VActSign                          ; Test VActSign
 C5C9  2605              bne     NEGATIVE_VACT                         ; If VActSign is 1 (Negative), Branch to NEGATIVE_VACT
 C5CB  FC0808        ldd         V_Act                                             ; Load Accumulator D with V_Act
 C5CE  2036          bra         BINARY_ASCII                      ; Branch Always to BINARY_ASCII
 C5D0                    
 C5D0            NEGATIVE_VACT:
 C5D0            	   
 C5D0  CC0000        ldd         #$0000                                    ; Load Accumulator D with $0000 (0)  
 C5D3  B30808        subd        V_Act                             ; Subtract V_Act from $0000 (0) to Get V_Act to Convert 
 C5D6  202E          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII 
 C5D8                    
 C5D8            UPDATE_KI:
 C5D8                
 C5D8  FC0814        ldd         Ki                                                        ; Load Accumulator D with Ki 
 C5DB  2029          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII 
 C5DD                    
 C5DD            UPDATE_KP:
 C5DD              
 C5DD  FC0818        ldd         Kp                                                        ; Load Accumulator D with Kp
 C5E0  2024          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII       
 C5E2            
 C5E2            UPDATE_ERROR:
 C5E2            	
 C5E2  F70874            tst     errorSign                         ; Test errorSign
 C5E5  2605              bne     NEGATIVE_ERROR                            ; If errorSign is 1 (Negative), Branch to NEGATIVE_ERROR
 C5E7  FC080A        ldd         Error                                             ; Load Accumulator D with Error
 C5EA  201A          bra         BINARY_ASCII                      ; Branch Always to BINARY_ASCII
 C5EC            
 C5EC            NEGATIVE_ERROR:
 C5EC            	   
 C5EC  CC0000        ldd         #$0000                                    ; Load Accumulator D with $0000 (0)
 C5EF  B3080A        subd        Error                             ; Subtract Error from $0000 (0) to Get Error to Convert
 C5F2  2012          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII
 C5F4                    
 C5F4            UPDATE_EFFORT:
 C5F4            	
 C5F4  F70873            tst     effortSign                                        ; Test effortSign           
 C5F7  2605              bne     NEGATIVE_EFFORT                           ; If effortSign is 1 (Negative), Branch to NEGATIVE_EFFORT
 C5F9  FC0824        ldd         Effort                                            ; Load Accumulator D with Effort
 C5FC  2008          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII       
 C5FE            
 C5FE            NEGATIVE_EFFORT:
 C5FE            	   
 C5FE  CC0000        ldd         #$0000                                    ; Load Accumulator D with $0000 (0)
 C601  B30824        subd        Effort                            ; Subtract Effort from $0000 (0) to Get Effort to Convert
 C604  2000          bra         BINARY_ASCII                              ; Branch Always to BINARY_ASCII
 C606                    
 C606            BINARY_ASCII:
 C606            	  
 C606  180308370877      movw    #updateBuffer, updatePointer  ; Load First Address of updateBuffer into updatePointer   
 C60C  180B000844        movb    #$00, updateCounter                       ; Clear updateCounter
 C611                       
 C611            BINARY_ASCII_LOOP:
 C611            
 C611  CE000A        ldx         #$000A                            ; Load Accumulator A with $000A (10)
 C614  CD0000        ldy         #$0000                            ; Load Y with $0000 (0)
 C617  1814          edivs                                         ; (Y:D)/X ==> Result into Y, Remainder ==> D
 C619  7D083C        sty         updateResult                      ; Store Y into updateResult
 C61C  CB30          addb        #$30                          ; Add $30 (30) to Accumulator B
 C61E  87            clra                                      ; Clear Accumulator A
 C61F  FE0877        ldx         updatePointer                 ; Load X with updatePointer Address
 C622  6B00          stab        0,x                               ; Store ASCII Value into updatePointer Address
 C624  720844        inc         updateCounter                 ; Increment the updateCounter
 C627  8D0000        cpy         #$0000                                    ; Compare Y to $0000 (0)
 C62A  18270009      lbeq        SIGN_CHECK                        ; If Y is 0, Branch to SIGN_CHECK
 C62E  08            inx                                           ; Increment X (updatePointer Address)
 C62F  7E0877        stx         updatePointer                     ; Store X into updatePointer
 C632  FC083C            ldd     updateResult                              ; Load D with updateResult
 C635  20DA              bra     BINARY_ASCII_LOOP                         ; Branch Always to BINARY_ASCII_LOOP
 C637            
 C637            SIGN_CHECK:
 C637            
 C637            
 C637  F70852            tst     VRefFlag                                          ; Test VRefFlag
 C63A  2627              bne             VREF_SIGN_CHECK                           ; If VRefFlag is 1 (True), Branch to VREF_SIGN_CHECK
 C63C  F70856            tst             KiFlag                                            ; Test KiFlag                 
 C63F  18260088          lbne    KI_KP_CHECK                                       ; If KiFlag is 1 (True), Branch to KI_KP_CHECK                
 C643  F70857            tst             KpFlag                                            ; Test KpFlag
 C646  18260081          lbne    KI_KP_CHECK                                       ; If KiFlag is 1 (True), Branch to KI_KP_CHECK
 C64A  F70853            tst     VActFlag                                          ; Test VActFlag
 C64D  1826002E          lbne    VACT_SIGN_CHECK                           ; If VActFlag is 1 (True), Branch to VACT_SIGN_CHECK  
 C651  F70855            tst     errorFlag                                         ; Test errorFlag      
 C654  1826003E          lbne    ERROR_SIGN_CHECK                          ; If errorFlag is 1 (True), Branch to ERROR_SIGN_CHECK
 C658  F70854            tst     effortFlag                                        ; Test effortFlag     
 C65B  1826004E          lbne    EFFORT_SIGN_CHECK                         ; If effortFlag is 1 (True), Branch to EFFORT_SIGN_CHECK
 C65F  1820014B          lbra    UPDATE_BUFFER_DONE                        ; Branch Always to UPDATE_BUFFER_DONE
 C663                                              
 C663            VREF_SIGN_CHECK:
 C663            
 C663  180B000852     movb    #$00, VRefFlag                               ; Set VRefFlag to 0 (False)
 C668  180B01086E        movb    #$01, updateLine1Flag             ; Set updateLine1Flag to 1 (True)     
 C66D  180B01086F        movb    #$01, updateLine2Flag             ; Set updateLine2Flag to 1 (True)      
 C672  CE0837            ldx     #updateBuffer                             ; Load X With the First Address of updateBuffer
 C675  CD0BB2        ldy     #VREF_BUF                             ; Load Y With the First Address of VRef_BUF
 C678  F70871        tst     VRefSign                                      ; Test VRefSign
 C67B  2648              bne         NEG_SIGN                                      ; If VRefSign is 1 (Negative), Branch to NEG_SIGN     
 C67D  2040              bra         POS_SIGN                      ; Branch Always to POS_SIGN                                      
 C67F            
 C67F            VACT_SIGN_CHECK:
 C67F                 
 C67F  180B000853        movb    #$00, VActFlag                            ; Set VActFlag to 0 (False)
 C684  CE0837            ldx             #updateBuffer                             ; Load X With the First Address of updateBuffer
 C687  CD0BB6        ldy         #VACT_BUF                                 ; Load Y With the First Address of VACT_BUF
 C68A  F70872        tst         VActSign                                  ; Test VActSign       
 C68D  2730              beq     POS_SIGN                                          ; If VActSign is 0 (Positive), Branch to NEG_SIGN
 C68F  180B000872        movb    #$00, VActSign                            ; Set VActFlag to 1 (Negative)
 C694  202F              bra             NEG_SIGN                                          ; Branch Always to NEG_SIGN
 C696                                                                
 C696            ERROR_SIGN_CHECK:
 C696                   
 C696  180B000855        movb    #$00, errorFlag                           ; Set errorFlag to 0 (False)
 C69B  CE0837            ldx             #updateBuffer                             ; Load X With the First Address of updateBuffer
 C69E  CD0BBA            ldy     #ERROR_BUF                                ; Load Y With the First Address of ERROR_BUF
 C6A1  F70874        tst         errorSign                         ; Test errorSign              
 C6A4  2719              beq     POS_SIGN                                      ; If errorSign is 0 (Positive), Branch to POS_SIGN  
 C6A6  180B000874        movb    #$00, errorSign                       ; Set errorSign to 1 (Negative)
 C6AB  2018              bra             NEG_SIGN                      ; Branch Always to NEG_SIGN                                                          
 C6AD            
 C6AD            EFFORT_SIGN_CHECK:
 C6AD                   
 C6AD  180B000854        movb    #$00, effortFlag                          ; Set effortFlag to 0 (False)
 C6B2  CE0837            ldx             #updateBuffer                             ; Load X With the First Address of updateBuffer
 C6B5  CD0BBE        ldy         #EFFORT_BUF                       ; Load Y With the First Address of EFFORT_BUF  
 C6B8  F70873            tst             effortSign
 C6BB  2608              bne             NEG_SIGN
 C6BD  2000              bra             POS_SIGN
 C6BF                       
 C6BF            POS_SIGN:
 C6BF            
 C6BF  1808402B          movb    #'+',0,y                                          ; Move '+' into the First Buffer Address              
 C6C3  2039              bra     UPDATE_OUT                                        ; Branch Always to UPDATE_OUT
 C6C5                       
 C6C5            NEG_SIGN:   
 C6C5            	   	  	
 C6C5  1808402D          movb    #'-',0,Y                          ; Move '-' into the First Buffer Address      
 C6C9  2033              bra     UPDATE_OUT                                ; Branch Always to UPDATE_OUT 
 C6CB            
 C6CB            KI_KP_CHECK:
 C6CB            
 C6CB  F70856            tst     KiFlag                                            ; Test KiFlag
 C6CE  2609              bne     KI_CHECK                                          ; If KiFlag is 1 (True), Branch to KI_CHECK
 C6D0  F70857            tst     KpFlag                                            ; Test KpFlag
 C6D3  2617              bne     KP_CHECK                                          ; If KpFlag is 1 (True), Branch to KP_CHECK
 C6D5  182000D5          lbra    UPDATE_BUFFER_DONE                        ; Branch Always to UPDATE_BUFFER_DONE
 C6D9            
 C6D9            KI_CHECK:
 C6D9  00        bgnd
 C6DA  180B000856        movb    #$00, KiFlag                              ; Set KiFlag to 0 (False)
 C6DF  180B01086F        movb    #$01, updateLine2Flag             ; Set updateLine2Flag to 0 (False)    
 C6E4  CE0837            ldx             #updateBuffer                             ; Load X With the First Address of updateBuffer       
 C6E7  CD0BC2        ldy         #KI_BUF                       ; Load Y With the First Address of KI_BUF         
 C6EA  2012              bra     UPDATE_OUT                                ; Branch Always to UPDATE_OUT_KI_KP
 C6EC            
 C6EC            KP_CHECK:
 C6EC            		 
 C6EC  180B000857        movb    #$00, KpFlag                              ; Set KpFlag to 0 (False)
 C6F1  180B01086F        movb    #$01, updateLine2Flag             ; Set updateLine2Flag to 1 (False)            
 C6F6  CE0837            ldx             #updateBuffer                             ; Load X With the First Address of updateBuffer
 C6F9  CD0BC7        ldy         #KP_BUF                       ; Load Y With the First Address of KP_BUF                 
 C6FC  2000              bra     UPDATE_OUT                                        ; Branch Always to UPDATE_OUT_KI_KP
 C6FE                                                       
 C6FE            UPDATE_OUT:
 C6FE            
 C6FE  730844        dec         updateCounter                             ; Decrement updateCounter
 C701  271A          beq         ONE_VALUE                                 ; If One ASCII Value, Branch to ONE_VALUE
 C703  730844        dec         updateCounter                             ; Decrement updateCounter     
 C706  275E          beq         TWO_VALUES                                ; If Two ASCII Values, Branch to TWO_VALUES   
 C708  730844        dec         updateCounter                             ; Decrement updateCounter     
 C70B  2767          beq         THREE_VALUES                      ; If Three ASCII Values, Branch to THREE_VALUES       
 C70D  730844        dec         updateCounter                             ; Decrement updateCounter     
 C710  2770          beq         FOUR_VALUES                               ; If Four ASCII Values, Branch to FOUR_VALUES                            
 C712  730844        dec         updateCounter                             ; Decrement updateCounter     
 C715  1827007F      lbeq        FIVE_VALUES                               ; If Five ASCII Values, Branch to FIVE_VALUES 
 C719  18200091      lbra        UPDATE_BUFFER_DONE                        ; Branch Always to UPDATE_BUFFER_DONE
 C71D                
 C71D            ONE_VALUE:
 C71D            
 C71D  F70856        tst         KiFlag
 C720  2613          bne         KI_ONE_VALUE
 C722  F70857            tst             KpFlag
 C725  2624          bne         KP_ONE_VALUE                     
 C727  180A0043      movb        0,x,3,y                                           ; Move the Single Value into the Third Buffer Position
 C72B  18084230          movb    #'0',2,y                                          ; Move 0 into the Second Buffer Position
 C72F  18084130          movb    #'0',1,y                                          ; Move 0 into the First Buffer Position            
 C733  2079          bra         UPDATE_BUFFER_DONE                        ; Branch Always to UPDATE_BUFFER_DONE
 C735            
 C735            KI_ONE_VALUE:
 C735                               
 C735  180A0044      movb        0,x,4,y                                           ; Move the Single Value into the Third Buffer Position
 C739  18084330          movb    #'0',3,y                                          ; Move the Single Value into the Third Buffer Position
 C73D  18084230          movb    #'0',2,y                                          ; Move 0 into the Second Buffer Position
 C741  18084130          movb    #'0',1,y                                          ; Move 0 into the First Buffer Position
 C745  18084030          movb    #'0',0,y                                          ; Move 0 into the First Buffer Position            
 C749  2063          bra         UPDATE_BUFFER_DONE                        ; Branch Always to UPDATE_BUFFER_DONE
 C74B                    
 C74B            KP_ONE_VALUE:
 C74B            
 C74B  180B000857     movb    #$00, KpFlag                   
 C750  180A0044      movb        0,x,4,y                                           ; Move the Single Value into the Third Buffer Position
 C754  18084330          movb    #'0',3,y                                          ; Move the Single Value into the Third Buffer Position
 C758  18084230          movb    #'0',2,y                                          ; Move 0 into the Second Buffer Position
 C75C  18084130          movb    #'0',1,y                                          ; Move 0 into the First Buffer Position 
 C760  18084030          movb    #'0',0,y                                          ; Move 0 into the First Buffer Position            
 C764  2048          bra         UPDATE_BUFFER_DONE                        ; Branch Always to UPDATE_BUFFER_DONE
 C766                    
 C766            TWO_VALUES:
 C766            
 C766  180A0043      movb   0,x,3,y                            ; Move the First Value into the Third Buffer Position
 C76A  180A0142      movb   1,x,2,y                                                ; Move the Second Value into the Second Buffer Position
 C76E  18084130          movb   #'0',1,y                                           ; Move 0 into the First Buffer Position
 C772  203A          bra    UPDATE_BUFFER_DONE                     ; Branch Always to UPDATE_BUFFER_DONE
 C774            
 C774            THREE_VALUES:
 C774            	
 C774  180A0043      movb   0,x,3,y                            ; Move the First Value into the Third Buffer Position
 C778  180A0142      movb   1,x,2,y                                                ; Move the Second Value into the Second Buffer Position
 C77C  180A0241      movb   2,x,1,y                                ; Move the Third Value into the First Buffer Position
 C780  202C          bra    UPDATE_BUFFER_DONE                     ; Branch Always to UPDATE_BUFFER_DONE
 C782            
 C782            FOUR_VALUES:
 C782            
 C782  180A0044      movb   0,x,4,y                                ; Move the First Value into the Fourth Buffer Position
 C786  180A0143      movb   1,x,3,y                                ; Move the Second Value into the Third Buffer Position
 C78A  180A0242      movb   2,x,2,y                                ; Move the Third Value into the Second Buffer Position
 C78E  180A0341      movb   3,x,1,y                                ; Move the Fourth Value into the First Buffer Position
 C792  18084030          movb   #'0',0,y                                           ; Move 0 into the First Buffer Position
 C796  2016          bra    UPDATE_BUFFER_DONE                     ; Branch Always to UPDATE_BUFFER_DONE
 C798            
 C798            FIVE_VALUES:
 C798            
 C798  180A0044      movb   0,x,4,y                                ; Move the First Value into the Fifth Buffer Position
 C79C  180A0143      movb   1,x,3,y                                ; Move the Second Value into the Fourth Buffer Position
 C7A0  180A0242      movb   2,x,2,y                                ; Move the Third Value into the Third Buffer Position
 C7A4  180A0341      movb   3,x,1,y                                ; Move the Fourth Value into the Second Buffer Position
 C7A8  180A0440      movb   4,x,0,y                                ; Move the Fifth Value into the First Buffer Position
 C7AC  2000          bra    UPDATE_BUFFER_DONE                     ; Branch Always to UPDATE_BUFFER_DONE
 C7AE            
 C7AE            
 C7AE                    
 C7AE            UPDATE_BUFFER_DONE:
 C7AE            
 C7AE  F70852            tst    VRefFlag                                           ; Test VRefFlag
 C7B1  1826FDFF          lbne   UPDATE_VREF                                        ; If VRefFlag is 1 (True), Branch to UPDATE_VREF
 C7B5  F70856            tst    KiFlag                                             ; Test KiFlag
 C7B8  1826FE1C          lbne   UPDATE_KI                                          ; If KiFlag is 1 (True), Branch to UPDATE_KI
 C7BC  F70857            tst    KpFlag                                             ; Test KpFlag
 C7BF  1826FE1A          lbne   UPDATE_KP                                          ; If KiFlag is 1 (True), Branch to UPDATE_KI
 C7C3  F70853            tst    VActFlag                                           ; Test VActFlag
 C7C6  1826FDFC          lbne   UPDATE_VACT                                        ; If VActFlag is 1 (True), Branch to UPDATE_VACT
 C7CA  F70855            tst    errorFlag                                          ; Test errorFlag
 C7CD  1826FE11          lbne   UPDATE_ERROR                                       ; If errorFlag is 1 (True), Branch to UPDATE_ERROR
 C7D1  F70854            tst    effortFlag                                         ; Test effortFlag
 C7D4  1826FE1C          lbne   UPDATE_EFFORT                              ; If effortFlag is 1 (True), Branch to UPDATE_EFFORT
 C7D8                       
 C7D8            UPDATE_BUFFER_EXIT: 
 C7D8            
 C7D8  F6083E            ldab   stateVariable                    
 C7DB  180B00086D     movb   #$00, updateValuesFlag                ; Set updateValuesFlag to 0 (False)
 C7E0  180B020800        movb   #$02, mmState                              ; Set the Mastermind State Variable to 2 (Hub)                  
 C7E5  3D                rts                                                                       ; Return to Main
 C7E6                    
 C7E6            ;=========  Mastermind - Miscellaneous Sub-Rountines / Branches   ==============
 C7E6            
 C7E6            BUFFER_STORE:
 C7E6            
 C7E6  F70852            tst        VRefFlag                                               ; Test VRefFlag
 C7E9  2626              bne        BUFFER_STORE_VREF                      ; If VRefFlag is 1 (True), Branch to BUFFER_STORE_VREF
 C7EB  B60843            ldaa   digitCounter                   ; Load Accumulator A with digitCounter
 C7EE  8105              cmpa   #$05                           ; Compare Accumulator A with $05 (5)
 C7F0  2C45              bge    BUFFER_STORE_LIMIT             ; If A is higher or equal than $05 (5), Branch to BUFFER_STORE_LIMIT
 C7F2  720843            inc    digitCounter                                       ; Increment digitCounter
 C7F5  FE0875            ldx    pointer                        ; Load X with pointer
 C7F8  F6082E            ldab   keyStore                                   ; Load Accumulator B with digitStore
 C7FB  6B00              stab   0,x                            ; Store Contents of B into X
 C7FD  08                inx                                   ; Increment X
 C7FE  7E0875            stx    pointer                        ; Store Contents of X into pointer
 C801  180B010847        movb   #$01, echoFlag                 ; Set echoFlag to 1 (True)
 C806  180B000846        movb   #$00, keyFlag                  ; Set keyFlag to 0 (False)
 C80B  180B020800        movb   #$02, mmState                              ; Set the Mastermind State Variable to 2 (Hub)
 C810  3D                rts                                                                       ; Return to Main
 C811            
 C811            BUFFER_STORE_VREF:
 C811            
 C811  B60843            ldaa   digitCounter                   ; Load Accumulator A with digitCounter
 C814  8103              cmpa   #$03                           ; Compater Accumulator with $03 (3)
 C816  2C1F              bge    BUFFER_STORE_LIMIT             ; If A is higher or equal than $03 (3), Branch to BUFFER_STORE_LIMIT
 C818  720843            inc    digitCounter                                       ; Increment digitCounter
 C81B  FE0875            ldx    pointer                        ; Load X with pointer
 C81E  F6082E            ldab   keyStore                                   ; Load Accumulator B with digitStore
 C821  6B00              stab   0,x                            ; Store Contents of B into X
 C823  08                inx                                   ; Increment X
 C824  7E0875            stx    pointer                        ; Store Contents of X into pointer
 C827  180B010847        movb   #$01, echoFlag                 ; Set echoFlag to 1 (True)
 C82C  180B000846        movb   #$00, keyFlag                  ; Set keyFlag to 0 (False)
 C831  180B020800        movb   #$02, mmState                              ; Set the Mastermind State Variable to 2 (Hub)
 C836  3D                rts                                                                       ; Return to Main
 C837                    
 C837            BUFFER_STORE_LIMIT:
 C837            
 C837  C600              ldab   #$00                           ; Load Accumulator B with $00 (0)
 C839  180B000847        movb   #$00, echoFlag                 ; Set echoFlag to 0 (True)
 C83E  180B000846        movb   #$00, keyFlag                  ; Set keyFlag to 0 (False)
 C843  180B00084B        movb   #$00, digitFlag                ; Set digitFlag to 0 (True)
 C848  180B020800        movb   #$02, mmState                              ; Set the Mastermind State Variable to 2 (Hub)
 C84D  3D                rts                                                                       ; Return to Main      
 C84E            
 C84E            CLEAR_TEMPLATE:
 C84E            
 C84E  FE0BB2        ldx    VREF_BUF                               ; Moves Zeros and '+' into VREF_BUF
 C851  1808002B      movb   #'+',0,x
 C855  18080130      movb   #'0',1,x
 C859  18080230      movb   #'0',2,x
 C85D  18080330      movb   #'0',3,x
 C861                   
 C861  FE0BB6            ldx    VACT_BUF                                   ; Moves Zeros and '+' into VACT_BUF
 C864  1808002B      movb   #'+',0,x
 C868  18080130      movb   #'0',1,x
 C86C  18080230      movb   #'0',2,x
 C870  18080330      movb   #'0',3,x
 C874                   
 C874  FE0BBA            ldx    ERROR_BUF                                  ; Moves Zeros and '+' into ERROR_BUF
 C877  1808002B      movb   #'+',0,x
 C87B  18080130      movb   #'0',1,x
 C87F  18080230      movb   #'0',2,x
 C883  18080330      movb   #'0',3,x
 C887                    
 C887  FE0BBE        ldx    EFFORT_BUF                             ; Moves Zeros and '+' into EFFORT_BUF
 C88A  1808002B      movb   #'+',0,x
 C88E  18080130      movb   #'0',1,x
 C892  18080230      movb   #'0',2,x
 C896  18080330      movb   #'0',3,x
 C89A                    
 C89A  FE0BC2        ldx    KI_BUF                                     ; Moves Zeros into KI_BUF
 C89D  18080030      movb   #'0',0,x
 C8A1  18080130      movb   #'0',1,x
 C8A5  18080230      movb   #'0',2,x
 C8A9  18080330      movb   #'0',3,x
 C8AD  18080430      movb   #'0',4,x     
 C8B1                       
 C8B1  FE0BC7        ldx    KP_BUF                                     ; Moves Zeros into KI_BUF
 C8B4  18080030      movb   #'0',0,x
 C8B8  18080130      movb   #'0',1,x
 C8BC  18080230      movb   #'0',2,x
 C8C0  18080430      movb   #'0',4,x
 C8C4  16FD41        jsr    UPDATELCDL1                            ; Jump to subtrountine to Update Line 1 of LCD
 C8C7  16FD68        jsr    UPDATELCDL2                            ; Jump to subtrountine to Update Line 2 of LCD
 C8CA  3D                rts                                                                       ; Return to Main      
 C8CB                    
 C8CB            ;=========================  Key Pad Driver Sub-Routine   =======================
 C8CB            
 C8CB            KPD:
 C8CB            
 C8CB  B60801            ldaa   kpdState                               
 C8CE  18270006          lbeq   kpdstate0                                  ; Initialization of Key Pad Driver
 C8D2  43                deca                                  
 C8D3  18270010          lbeq   kpdstate1                                  ; Wait for the Key Press to Be Stored in Buffer
 C8D7  3D                rts                                                                       ; Return to Main      
 C8D8            
 C8D8            ;========  Key Pad Driver State 0 - Initialization of Key Pad Driver   =========
 C8D8            
 C8D8            kpdstate0: 	
 C8D8            			
 C8D8  16FE5C        jsr    INITKEY                        ; Jump to Subroutine INITKEY
 C8DB  16FE71        jsr    FLUSH_BFR                      ; Jump to Subroutine FLUSH_BFR
 C8DE  16FE67        jsr    KP_ACTIVE                      ; Jump to Subroutine KP_ACTIVE
 C8E1  180B010801     movb   #$01, kpdState                 ; Set the KPD State Variable to 1
 C8E6  3D                rts                                                                       ; Return to Main      
 C8E7            
 C8E7            ;== Key Pad Driver State 1 - Wait for the Key Press to Be Stored in Buffer   ===
 C8E7            
 C8E7            kpdstate1:
 C8E7                   
 C8E7  F70BB1        tst    L$KEY_FLG                      ; Test L$KEY_FLG
 C8EA  2611              bne        NO_KEY_PRESS                           ; If L$KEY_FLG has Key, Branch to NO_KEY_PRESS
 C8EC  16FE77        jsr    GETCHAR                        ; Jump to Subroutine GETCHAR
 C8EF  7B082E            stab   keyStore                       ; Store ASCII Char from Accumulator B into keyStore
 C8F2  180B010846        movb   #$01, keyFlag                  ; Set keyFlag to 1 (True)
 C8F7  180B010801        movb   #$01, kpdState                             ; Set the KPD State Variable to 1
 C8FC  3D                rts                                                                       ; Return to Main
 C8FD            
 C8FD            NO_KEY_PRESS:
 C8FD            
 C8FD  180B010801        movb   #$01,kpdState                              ; Set the KPD State Variable to 1
 C902  3D                rts                                                                       ; Return to Main
 C903            
 C903            ;=============================  Display Sub-Routine   ==========================
 C903            
 C903            DISPLAY:
 C903            
 C903  B60802            ldaa   displayState                   ; Display to be Branched to Depending on Value
 C906  18270029          lbeq   displaystate0                  ; Initalize LCD Screen & Cursor
 C90A  43                deca
 C90B  18270036          lbeq   displaystate1                  ; Display Hub
 C90F  43                deca
 C910  18270087          lbeq   displaystate2                  ; Update LCD Template Values
 C914  43                deca
 C915  182700D4          lbeq   displaystate3                  ; Display Ref Velocity Prompt 
 C919  43                deca
 C91A  18270120          lbeq   displaystate4                  ; Display Ki Prompt
 C91E  43                deca
 C91F  1827016C          lbeq   displaystate5                  ; Display Kp Prompt
 C923  43                deca
 C924  182701E3          lbeq   displaystate6                  ; Initializing & Printing Digit
 C928  43                deca
 C929  18270225          lbeq   displaystate7                  ; Backspace       
 C92D  43                deca
 C92E  1827036E          lbeq   displaystate8                  ; LCD Update
 C932  3D            rts         
 C933            
 C933            ;==================== Display State 0 - Initialize LCD Screen & Cursor ===================
 C933                    
 C933            displaystate0:
 C933            
 C933  16FB00            jsr        INITLCD                        ; Initalize LCD Screen
 C936  16FC37            jsr    CLRSCREEN                      ; Clear LCD Screen
 C939  16FC61            jsr    CURSOR                         ; Show Cursor in LCD Screen
 C93C  16FD3A            jsr        LCDTEMPLATE                                    ;     Library Command to Update LCD Screen          
 C93F  180B010802        movb   #$01, displayState                     ; Set Next Display to HUB
 C944  3D                rts
 C945            
 C945            ;============================= Display State 1 - Display Hub =============================
 C945                    
 C945            displaystate1:
 C945             
 C945  F70868        tst    VRefPromptFlag                     ; Test to see if C Character (V_Ref) has been Pressed
 C948  2627          bne    DISPLAY_VREF_PROMPT            ; Branch VREFFLAG if true
 C94A  F70869        tst    KiPromptFlag                   ; Test KIFLAG
 C94D  2628          bne    DISPLAY_KI_PROMPT              ; Branch to KI_DISPLAY, if true
 C94F  F7086A        tst    KpPromptFlag                   ; TEST WAVE_FLAG
 C952  2629          bne    DISPLAY_KP_PROMPT              ; If it is true then branch and display
 C954  F70847        tst    echoFlag                       ; Test ECHOFLAG
 C957  18260028      lbne   KEY_PRINT                      ; If ECHOFLAG is TRUE, branch to ECHO
 C95B  F70867        tst    backspacePrint                 ; Test BSPACEFLAG
 C95E  18260027      lbne   BACKSPACE_PRINT                ; If BSPACEFLAG is TRUE, branch to DISPBSPACE
 C962  F7084F            tst        stateVariableFlag              ; Test VariableFlag
 C965  18260026          lbne   STATE_VARIABLE_PRINT           ; If stateVariableFlag is TRUE, Branch to STATE_VARIABLE_PRINT
 C969  F70851            tst        LCDUpdateFlag                  ; Test LCDUpdateFlag
 C96C  18260025          lbne   LCD_UPDATE_PRINT               ; If LCDUpdateFlag is TRUE , Branch to LCD_UPDATE_PRINT
 C970  3D            rts
 C971                    
 C971            DISPLAY_VREF_PROMPT:
 C971            
 C971  180B020802     movb   #$02, displayState             ; Set state to display DISP VREF message
 C976  3D            rts 
 C977                            
 C977            DISPLAY_KI_PROMPT: 
 C977            
 C977  180B030802     movb   #$03, displayState             ; Set state to KI display
 C97C  3D            rts
 C97D                       
 C97D            DISPLAY_KP_PROMPT:
 C97D            
 C97D  180B040802     movb   #$04, displayState             ; Set state to KP display
 C982  3D            rts
 C983                    
 C983            KEY_PRINT:
 C983            
 C983  180B050802     movb   #$05, displayState             ; Set state to echo digits pressed
 C988  3D            rts
 C989             
 C989            BACKSPACE_PRINT:
 C989            
 C989  180B060802     movb   #$06, displayState             ; Set state to display Backspace
 C98E  3D            rts
 C98F            
 C98F            STATE_VARIABLE_PRINT:
 C98F            
 C98F  180B070802     movb   #$07, displayState             ; Set state to Update LCD screen
 C994  3D            rts
 C995            
 C995            LCD_UPDATE_PRINT:
 C995            
 C995  180B080802     movb   #$08, displayState             ; Set state to Update LCD screen
 C99A  3D            rts
 C99B            
 C99B            
 C99B            ;===================== Display State 2 - VRef Prompt Print =====================
 C99B                    
 C99B            displaystate2:
 C99B            
 C99B  8640          ldaa   #$40                           ; Load Accumulator A with LCD Address $07
 C99D  CEC9AD        ldx    #VREF_PRINT_MESSAGE            ; Load Index Register X with Address of NO_DIGITS_PRINT
 C9A0  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 C9A3  FE0879        ldx    displayPointer                 ; Load X with displayPointer
 C9A6  E600          ldab   0,x                            ; Load B with the Contents in X
 C9A8  18270027      lbeq   DONE_VREF_PRINT                                ; If B=$00, Branch to DONE_NO_DIGITS_PRINT
 C9AC  3D            rts
 C9AD            
 C9AD            VREF_PRINT_MESSAGE:
 C9AD            
 C9AD  454E54455220565245463A20202020202020202020202020202020202020202020202020  .ascii  'ENTER VREF:                         '
 C9D1  00            .byte       $00
 C9D2  3D            rts               
 C9D3                       
 C9D3            DONE_VREF_PRINT:
 C9D3            	
 C9D3  864C              ldaa   #$4C                           ; Load A with LCD Address of 76
 C9D5  16FC43            jsr        SETADDR                        ; Set the Cursor at The Address in A
 C9D8  180B000868        movb   #$00, VRefPromptFlag           ; Clear the VRefPromptFlag
 C9DD  180B010849        movb   #$01, firstChar                ; Clear firstChar Flag
 C9E2  180B01086B        movb   #$01, digitAllowed                     ; Clear the digitAllowed Flag   
 C9E7  180B010802     movb   #$01, displayState             ; Return to Display State 1
 C9EC  3D                rts
 C9ED                    
 C9ED            ;===================== Display State 3 - Ki Prompt Print =======================
 C9ED                    
 C9ED            displaystate3:
 C9ED            
 C9ED  8640          ldaa   #$40                           ; Load Accumulator A with LCD Address 64
 C9EF  CEC9FF        ldx    #KI_PRINT_MESSAGE              ; Load Index Register X with Address of NO_DIGITS_PRINT
 C9F2  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 C9F5  FE0879        ldx    displayPointer                 ; Load X with displayPointer
 C9F8  E600          ldab   0,x                            ; Load B with the Contents in X
 C9FA  18270026      lbeq   DONE_KI_PRINT                              ; If B=$00, Branch to DONE_NO_DIGITS_PRINT
 C9FE  3D            rts
 C9FF            
 C9FF            KI_PRINT_MESSAGE:
 C9FF            
 C9FF  454E54455220313032342A4B493A202020202020202020202020202020202020202020    .ascii  'ENTER 1024*KI:                     '
 CA22  00            .byte       $00
 CA23  3D            rts               
 CA24                       
 CA24            DONE_KI_PRINT:
 CA24            	
 CA24  864F              ldaa   #$4F                           ; Load Accumulator A with LCD Address 79
 CA26  16FC43            jsr        SETADDR                        ; Set the Cursor at The Address in A
 CA29  180B000869        movb   #$00, KiPromptFlag             ; Clear KiPromptFlag
 CA2E  180B010849        movb   #$01, firstChar                ; Clear firstChar Flag 
 CA33  180B01086B        movb   #$01, digitAllowed                     ; Clear digitAllowed           
 CA38  180B010802     movb   #$01, displayState             ; Return to Display State 1
 CA3D  3D                rts
 CA3E                    
 CA3E            ;===================== Display State 4 - Ki Prompt Print =======================
 CA3E                    
 CA3E            displaystate4:
 CA3E            
 CA3E  8640          ldaa   #$40                           ; Load Accumulator A with LCD Address $07
 CA40  CECA50        ldx    #KP_PRINT_MESSAGE              ; Load Index Register X with Address of NO_DIGITS_PRINT
 CA43  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 CA46  FE0879        ldx    displayPointer                 ; Load X with displayPointer
 CA49  E600          ldab   0,x                            ; Load B with the Contents in X
 CA4B  18270026      lbeq   DONE_KP_PRINT                                  ; If B=$00, Branch to DONE_NO_DIGITS_PRINT
 CA4F  3D            rts
 CA50            
 CA50            KP_PRINT_MESSAGE:
 CA50            
 CA50  454E54455220313032342A4B503A202020202020202020202020202020202020202020    .ascii  'ENTER 1024*KP:                     '
 CA73  00            .byte       $00
 CA74  3D            rts               
 CA75             
 CA75            DONE_KP_PRINT:
 CA75            	
 CA75  864F              ldaa   #$4F                           ; Load Accumulator A with LCD Address 79
 CA77  16FC43            jsr        SETADDR                        ; Set the Cursor at The Address in A
 CA7A  180B00086A        movb   #$00, KpPromptFlag             ; Clear KpPromptFlag
 CA7F  180B010849        movb   #$01, firstChar                ; Clear firstChar
 CA84  180B01086B        movb   #$01, digitAllowed                     ; Clear digitAllowed   
 CA89  180B010802     movb   #$01, displayState             ; Return to Display State 1
 CA8E  3D                rts
 CA8F                    
 CA8F            ;================ Display State 5 - Initializing & Printing Digit for Entry ====
 CA8F                    
 CA8F            displaystate5:
 CA8F            
 CA8F  F70866            tst    VRefPosPrintFlag               ; Test VRefPosPrintFlag
 CA92  1826000B          lbne   PRINT_POSITIVE                 ; If VRefPosPrintFlag TRUE, Branch to PRINT_POSITIVE
 CA96  F70865            tst        VRefNegPrintFlag               ; Test VRefNegPrintFlag
 CA99  1826000D          lbne   PRINT_NEG                      ; If VRefNegPrintFlag TRUE, Branch to PRINT_NEG
 CA9D  18200012          lbra   PRINT_INIT                     ; Otherwise, Branch to PRINT_INIT
 CAA1                    
 CAA1            PRINT_POSITIVE:
 CAA1            
 CAA1  C62B              ldab   #$2B                           ; Load Accumulator B with ASCII value of '+'
 CAA3  16FC25            jsr        OUTCHAR                        ; Print Character Stored in B
 CAA6  1820004D          lbra   SIGN_PRINT_DONE                ; Branch to SIGN_PRINT_DONE
 CAAA                    
 CAAA            PRINT_NEG:
 CAAA            	
 CAAA  C62D              ldab   #$2D                           ; Load Accumulator B with ASCII value of '-'
 CAAC  16FC25            jsr        OUTCHAR                        ; Print Character Stored in B
 CAAF  18200044          lbra   SIGN_PRINT_DONE                ; Branch to SIGN_PRINT_DONE
 CAB3                    
 CAB3            PRINT_INIT:	
 CAB3            	  
 CAB3  B60843        ldaa   digitCounter                   ; Load Accumulator A with digitCounter
 CAB6  8100          cmpa   #$00                           ; Compare A with $00 
 CAB8  260A              bne        DIGIT_NOT_FIRST                ; If A not $00, Branch to DIGIT_NOT_FIRST
 CABA  2000              bra        PRINT_FIRST_DIGIT              ; Otherwise, Branch to PRINT_FIRST_DIGIT
 CABC              
 CABC            PRINT_FIRST_DIGIT:
 CABC            
 CABC  F6082E            ldab   keyStore                       ; Load Accumulator B With digitStore
 CABF  16FC25            jsr        OUTCHAR                        ; Print Character Stored in B
 CAC2  2025              bra        DIGIT_PRINT_DONE               ; Branch to INIT_PRINT_DONE
 CAC4                       
 CAC4            DIGIT_NOT_FIRST:
 CAC4            
 CAC4  F70852            tst        VRefFlag                       ; Test VRefFlag
 CAC7  1826000F          lbne   DIGIT_NOT_FIRST_VREF           ; If VRefFlag TRUE, Branch to DIGIT_NOT_FIRST_VREF
 CACB  B60843            ldaa   digitCounter                   ; Load Accumulator A with digitCounter
 CACE  8106              cmpa   #$06                           ; Compare A with $03
 CAD0  2C17          bge    DIGIT_PRINT_DONE               ; If Value in A > $03, Branch to DIGIT_PRINT_DONE
 CAD2  F6082E            ldab   keyStore                       ; Load Accumulator B with digitStore
 CAD5  16FC25            jsr        OUTCHAR                        ; Print Character of ASCII Value in Stored in B
 CAD8  200F              bra        DIGIT_PRINT_DONE               ; Branch to INIT_PRINT_DONE
 CADA                    
 CADA            DIGIT_NOT_FIRST_VREF:
 CADA            
 CADA  B60843            ldaa   digitCounter                   ; Load Accumulator A with digitCounter
 CADD  8104              cmpa   #$04                           ; Compare A with $03
 CADF  2C08          bge    DIGIT_PRINT_DONE               ; If Value in A > $03, Branch to DIGIT_PRINT_DONE
 CAE1  F6082E            ldab   keyStore                       ; Load Accumulator B with digitStore
 CAE4  16FC25            jsr        OUTCHAR                        ; Print Character of ASCII Value in Stored in B
 CAE7  2000              bra        DIGIT_PRINT_DONE               ; Branch to INIT_PRINT_DONE 
 CAE9                    
 CAE9            DIGIT_PRINT_DONE:
 CAE9            
 CAE9  790847            clr        echoFlag                       ; Set echoFlag to FALSE
 CAEC  180B01084B        movb   #$01, digitFlag                ; Clear digitFlag
 CAF1  180B010802        movb   #$01, displayState             ; Return Back to Display Hub
 CAF6  3D                rts
 CAF7            
 CAF7            SIGN_PRINT_DONE:
 CAF7            
 CAF7  790847            clr        echoFlag                       ; Set echoFlag to FALSE
 CAFA  180B01086C        movb   #$01, VRefSignFlag             ; Set VRefSignFlag
 CAFF  790866            clr    VRefPosPrintFlag               ; Clear VRefPosPrintFlag
 CB02  790865            clr    VRefNegPrintFlag               ; Clear VRefPosPrintFlag AGAIN =)
 CB05  180B010802        movb   #$01, displayState             ; Return Back to Display Hub
 CB0A  3D                rts
 CB0B            
 CB0B            ;============================ Display State 6 - Backspace ======================
 CB0B            
 CB0B            displaystate6:
 CB0B            
 CB0B  B60803            ldaa   backspaceState
 CB0E  1827000A          lbeq   backspacestate0                ; Backs up Cursor 
 CB12  43                deca
 CB13  1827001A          lbeq   backspacestate1                ; Space Print
 CB17  43                deca
 CB18  18270020          lbeq   backspacestate2                ; Backs up Cursor and Return to Display State 1
 CB1C            
 CB1C            backspacestate0:
 CB1C            
 CB1C  730843            dec        digitCounter                   ; Decrement digitCounter
 CB1F  FE0875            ldx    pointer                        ; Load Index Register X with pointer
 CB22  09                dex                                   ; Decrement Index Register X
 CB23  7E0875            stx        pointer                        ; Store Index Register X into pointer 
 CB26  C608              ldab   #$08                           ; Load Accumulator B with ASCII Value of Backspace
 CB28  16FC25            jsr        OUTCHAR                        ; Moves the Cursor Back One Space On LCD
 CB2B  180B010803        movb   #$01, backspaceState           ; Return to backspaceState 1
 CB30  3D                rts
 CB31                    
 CB31            backspacestate1:
 CB31            
 CB31  C620              ldab   #$20                           ; Load Accumulator B with ASCII Value of Space
 CB33  16FC25            jsr        OUTCHAR                        ; Prints a Space on LCD and Moves the Cursor to Next Address
 CB36  180B020803        movb   #$02, backspaceState           ; Return to backspaceState 2
 CB3B  3D                rts
 CB3C            
 CB3C            backspacestate2:	
 CB3C            	
 CB3C  C608              ldab   #$08                           ; Load Accumulator B with ASCII Value of Backspace
 CB3E  16FC25            jsr        OUTCHAR                        ; Moves the Cursor Back One Space On LCD
 CB41  180B000803        movb   #$00, backspaceState           ; Return to backspace state 0
 CB46  180B010802        movb   #$01, displayState             ; Return to Display State 1
 CB4B  79084A            clr        backspaceFlag                  ; Set backspaceFlag to FALSE
 CB4E  790867            clr        backspacePrint                 ; Set backspaceFlag to FALSE
 CB51  3D                rts
 CB52              
 CB52            ;===================== Display State 7 - State Variable Print ==================
 CB52            
 CB52            displaystate7:
 CB52            
 CB52  B60804        ldaa   stateVariableState  
 CB55  43            deca   
 CB56  2711          beq    ON_OFF_PROMPT                  ; Determine State (on/off)
 CB58  43            deca
 CB59  2720          beq    OPEN_CLOSED_PROMPT             ; Open Loop Display
 CB5B  43            deca
 CB5C  2728          beq    AUTO_MANUAL_PROMPT             ; Update LCD Automatically
 CB5E  180B010804        movb   #$01, stateVariableState       ; Go to ON_OFF_PROMPT on Next Pass Through Display State 7
 CB63  180B010802        movb   #$01, displayState             ; Return to Display HUB On Next Pass Through Display
 CB68  3D            rts  
 CB69            
 CB69            ON_OFF_PROMPT:
 CB69            
 CB69  F70870        tst    promptUpFlag                   ; Test promptUpFlag
 CB6C  1826011B          lbne   SKIP_STATE_VARIABLE_PRINT      ; If promptUpFlag is TRUE, Branch to SKIP_STATE_VARIABLE_PRINT
 CB70  F7084D        tst    RUN                            ; Test RUN
 CB73  1827003F      lbeq   DISPLAY_STOP_VARIABLE          ; If RUN is TRUE, Branch to DISPLAY_STOP_VARIABLE
 CB77  18200016          lbra   DISPLAY_RUN_VARIABLE           ; Otherwise, Branch to DISPLAY_RUN_VARIABLE
 CB7B            
 CB7B            OPEN_CLOSED_PROMPT:
 CB7B            
 CB7B  F7084E            tst        loopSetFlag                    ; Test loopSetFlag
 CB7E  18270085          lbeq   DISPLAY_CL_VARIABLE            ; If loopSetFlag is TRUE, Branch to DISPLAY_CL_VARIABLE
 CB82  18200058          lbra   DISPLAY_OL_VARIABLE            ; Otherwise, Branch to DISPLAY_OL_VARIABLE
 CB86            
 CB86            AUTO_MANUAL_PROMPT:
 CB86            
 CB86  F70850            tst        autoManualFlag                 ; Test autoManualFlag
 CB89  182600A0          lbne   DISPLAY_AUTO_VARIABLE          ; If autoManualFlag is TRUE, Branch to DISPLAY_AUTO_VARIABLE
 CB8D  182000CB          lbra   DISPLAY_MANUAL_VARIABLE        ; Otherwise, Branch to DISPLAY_MANUAL_VARIABLE
 CB91                    
 CB91            DISPLAY_RUN_VARIABLE:
 CB91            
 CB91  8664          ldaa   #$64                           ; Load Accumulator A with $40
 CB93  CECBA3        ldx    #RUN_VARIABLE_MESSAGE          ; Load Index Register X with Address of F2_INIT_MESSAGE
 CB96  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 CB99  FE0879        ldx    displayPointer                 ; Load Index Register X with value in displayPointer
 CB9C  E600          ldab   0,x                            ; Load B with the Contents of X
 CB9E  18270004      lbeq   DONE_RUN_VARIABLE_PRINT        ; If X = $00, Branch to DONE_F2_INIT_PRINT
 CBA2  3D            rts
 CBA3            
 CBA3            RUN_VARIABLE_MESSAGE :
 CBA3            
 CBA3  52            .ascii 'R'
 CBA4  00            .byte  $00               
 CBA5  3D                rts
 CBA6            
 CBA6            DONE_RUN_VARIABLE_PRINT:
 CBA6             
 CBA6  180B020804     movb   #$02, stateVariableState       ; Set next Display State 7 to Execute OPEN_CLOSED_PROMPT
 CBAB  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CBB0  180B010849     movb   #$01, firstChar                ; Clear firstChar
 CBB5  3D            rts 
 CBB6                    
 CBB6            DISPLAY_STOP_VARIABLE:
 CBB6            
 CBB6  8664          ldaa   #$64                           ; Load Accumulator A with $40
 CBB8  CECBC8        ldx    #STOP_VARIABLE_MESSAGE         ; Load Index Register X with Address of F2_INIT_MESSAGE
 CBBB  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 CBBE  FE0879        ldx    displayPointer                 ; Load Index Register X with value in displayPointer
 CBC1  E600          ldab   0,x                            ; Load B with the Contents of X
 CBC3  18270004      lbeq   DONE_STOP_VARIABLE_PRINT       ; If X = $00, Branch to DONE_F2_INIT_PRINT
 CBC7  3D            rts
 CBC8            
 CBC8            STOP_VARIABLE_MESSAGE:
 CBC8            
 CBC8  53            .ascii 'S'
 CBC9  00            .byte  $00               
 CBCA  3D                rts
 CBCB            
 CBCB            DONE_STOP_VARIABLE_PRINT:
 CBCB            
 CBCB  180B020804     movb   #$02, stateVariableState       ; Set next Display State 7 to Execute OPEN_CLOSED_PROMPT
 CBD0  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CBD5  180B010849     movb   #$01, firstChar                ; Clear firstChar
 CBDA  7B083E            stab   stateVariable                  ; Store Contents of B into stateVariable
 CBDD  3D            rts   
 CBDE                    
 CBDE            DISPLAY_OL_VARIABLE:
 CBDE            
 CBDE  8665          ldaa   #$65                           ; Load Accumulator A with $40
 CBE0  CECBF0        ldx    #OL_VARIABLE_MESSAGE           ; Load Index Register X with Address of F2_INIT_MESSAGE
 CBE3  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 CBE6  FE0879        ldx    displayPointer                 ; Load Index Register X with value in displayPointer
 CBE9  E600          ldab   0,x                            ; Load B with the Contents of X
 CBEB  18270005      lbeq   DONE_OL_VARIABLE_PRINT         ; If X = $00, Branch to DONE_F2_INIT_PRINT
 CBEF  3D            rts
 CBF0            
 CBF0            OL_VARIABLE_MESSAGE:
 CBF0            
 CBF0  4F4C          .ascii 'OL'
 CBF2  00            .byte  $00               
 CBF3  3D                rts
 CBF4            
 CBF4            DONE_OL_VARIABLE_PRINT:
 CBF4            
 CBF4  180B030804     movb   #$03, stateVariableState       ; Set Next Display State 7 to Execute AUTO_MANUAL_PROMPT
 CBF9  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CBFE  180B010849     movb   #$01, firstChar                ; Clear firstChar
 CC03  7B083E            stab   stateVariable                  ; Store Contents of B into stateVariable
 CC06  3D            rts 
 CC07                    
 CC07            DISPLAY_CL_VARIABLE:
 CC07            
 CC07  8665          ldaa   #$65                           ; Load Accumulator A with $40
 CC09  CECC19        ldx    #CL_VARIABLE_MESSAGE           ; Load Index Register X with Address of F2_INIT_MESSAGE
 CC0C  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 CC0F  FE0879        ldx    displayPointer                 ; Load Index Register X with value in displayPointer
 CC12  E600          ldab   0,x                            ; Load B with the Contents of X
 CC14  18270005      lbeq   DONE_CL_VARIABLE_PRINT         ; If X = $00, Branch to DONE_F2_INIT_PRINT
 CC18  3D            rts
 CC19            
 CC19            CL_VARIABLE_MESSAGE :
 CC19            
 CC19  434C          .ascii 'CL'
 CC1B  00            .byte  $00               
 CC1C  3D                rts
 CC1D            
 CC1D            
 CC1D            DONE_CL_VARIABLE_PRINT:
 CC1D            
 CC1D  180B030804     movb   #$03, stateVariableState       ; Set Next Display State 7 to Execute AUTO_MANUAL_PROMPT
 CC22  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CC27  180B010849     movb   #$01, firstChar                ; Clear firstChar
 CC2C  3D            rts 
 CC2D                    
 CC2D            DISPLAY_AUTO_VARIABLE:
 CC2D            
 CC2D  8667          ldaa   #$67                           ; Load Accumulator A with $40
 CC2F  CECC3F        ldx    #AUTO_VARIABLE_MESSAGE         ; Load Index Register X with Address of F2_INIT_MESSAGE
 CC32  16CCD4        jsr    DISPLAY_CHAR                       ; Jump to Subroutine DISPLAY_CHAR
 CC35  FE0879        ldx    displayPointer                 ; Load Index Register X with value in displayPointer
 CC38  E600          ldab   0,x                            ; Load B with the Contents of X
 CC3A  18270004      lbeq   DONE_AUTO_VARIABLE_PRINT       ; If X = $00, Branch to DONE_F2_INIT_PRINT
 CC3E  3D            rts
 CC3F            
 CC3F            AUTO_VARIABLE_MESSAGE :
 CC3F            
 CC3F  41            .ascii 'A'
 CC40  00            .byte  $00               
 CC41  3D                rts
 CC42            
 CC42            
 CC42            DONE_AUTO_VARIABLE_PRINT:
 CC42            
 CC42  180B010804     movb   #$01, stateVariableState       ; Set next Display State 7 to Execute OPEN_CLOSED_PROMPT
 CC47  180B00084F        movb   #$00, stateVariableFlag        ; Clear stateVariableFlag
 CC4C  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CC51  180B010849     movb   #$01, firstChar                ; Set firstChar
 CC56  180B000870        movb   #$00, promptUpFlag             ; Clear promptUpFlag
 CC5B  3D            rts 
 CC5C                    
 CC5C            DISPLAY_MANUAL_VARIABLE:
 CC5C            
 CC5C  8667          ldaa   #$67                           ; Load Accumulator A with $40
 CC5E  CECC6E        ldx    #MANUAL_VARIABLE_MESSAGE       ; Load Index Register X with Address of F2_INIT_MESSAGE
 CC61  16CCD4        jsr    DISPLAY_CHAR                               ; Jump to Subroutine DISPLAY_CHAR
 CC64  FE0879        ldx    displayPointer                 ; Load Index Register X with value in displayPointer
 CC67  E600          ldab   0,x                            ; Load B with the Contents of X
 CC69  18270004      lbeq   DONE_MANUAL_VARIABLE_PRINT     ; If X = $00, Branch to DONE_F2_INIT_PRINT
 CC6D  3D            rts
 CC6E            
 CC6E            MANUAL_VARIABLE_MESSAGE :
 CC6E            
 CC6E  4D            .ascii 'M'
 CC6F  00            .byte  $00               
 CC70  3D                rts
 CC71            
 CC71            
 CC71            DONE_MANUAL_VARIABLE_PRINT:
 CC71            
 CC71  180B010804     movb   #$01, stateVariableState       ; Set next Display State 7 to Execute OPEN_CLOSED_PROMP
 CC76  180B00084F        movb   #$00, stateVariableFlag        ; Clear stateVariableFlag
 CC7B  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CC80  180B010849     movb   #$01, firstChar                ; Set firstChar
 CC85  180B000870        movb   #$00, promptUpFlag             ; Clear promptUpFlag
 CC8A  3D            rts 
 CC8B            
 CC8B            SKIP_STATE_VARIABLE_PRINT:
 CC8B            
 CC8B  180B010804     movb   #$01, stateVariableState       ; Set next Display State 7 to Execute OPEN_CLOSED_PROMP
 CC90  180B00084F        movb   #$00, stateVariableFlag        ; Clear stateVariableFlag
 CC95  180B010802     movb   #$01, displayState             ; Return to Display State HUB
 CC9A  180B010849     movb   #$01, firstChar                ; Set firstChar
 CC9F  3D            rts 
 CCA0                    
 CCA0            ;===================== Display State 8 -  Update LCD Display ==================
 CCA0                    
 CCA0            displaystate8:
 CCA0             	
 CCA0  F70850            tst        autoManualFlag                 ; Test autoManualFlag
 CCA3  271F              beq    UPDATE_LCD_DONE                ; If autoManualFlag is FALSE, Branch to UPDATE_LCD_DONE
 CCA5                    
 CCA5  F70870            tst    promptUpFlag                   ; Test promptUpFlag
 CCA8  261A          bne    UPDATE_LCD_DONE                ; If promptUpFlag is TRUE, Branch to UPDATE_LCD_DONE 
 CCAA                    
 CCAA  180B000851     movb   #$00, LCDUpdateFlag            ; Otherwise, Clear LCDUpdateFlag
 CCAF            
 CCAF  16FD41        jsr    UPDATELCDL1                    ; Update the LCD top line
 CCB2  F7086F        tst    updateLine2Flag                ; See if I want Update LCD Screen Line 2
 CCB5  270D          beq    UPDATE_LCD_DONE                        ; If updateLine2Flag FALSE, Branch to UPDATE_LCD_DONE
 CCB7  16FD68        jsr    UPDATELCDL2                    ; Update the LCD bottom line
 CCBA  180B01084F        movb   #$01, stateVariableFlag        ; Set stateVariableFlag
 CCBF  180B00086F     movb   #$00, updateLine2Flag          ; Clear Update Line 2
 CCC4            
 CCC4            UPDATE_LCD_DONE:
 CCC4  180B010802     movb   #$01, displayState             ; Set next state to: Display HUB
 CCC9  180B01084F        movb   #$01, stateVariableFlag        ; Set stateVariableFlag
 CCCE  180B000851     movb   #$00, LCDUpdateFlag            ; Clear LCD flag
 CCD3  3D            rts   
 CCD4                       
 CCD4            ;=========  Display - Miscellaneous Sub-Rountines / Branches   =================
 CCD4            
 CCD4            DISPLAY_CHAR:
 CCD4            
 CCD4  F70849        tst    firstChar                      ; Test firstChar to Raise Flags
 CCD7  270A          beq    DISPLAY_WRITE                  ; Branch to DISPLAY_WRITE if firstChar = 0 (FALSE)
 CCD9  7E0879        stx    displayPointer                 ; Store value of x into displayPointer
 CCDC  16FC43            jsr    SETADDR                        ; Set cursor to particular LCD address in A
 CCDF  790849        clr    firstChar                      ; Clear firstChar
 CCE2  3D            rts
 CCE3            
 CCE3            DISPLAY_WRITE:
 CCE3            
 CCE3  FE0879        ldx    displayPointer                 ; Load x with value in Display Pointer
 CCE6  08            inx                                   ; Increment x
 CCE7  7E0879        stx    displayPointer                 ; Store Display Pointer with incremented x
 CCEA  16FC25        jsr    OUTCHAR                        ; Print character
 CCED  3D            rts
 CCEE                    
 CCEE            ;========================= Timer Channel 0 Sub-Routine =========================
 CCEE                    
 CCEE            TIMER_C0:
 CCEE            	
 CCEE  B60805            ldaa   tc0State                       ; Load Accumulator A with tc0State
 CCF1  2704              beq    tc0state0                      ; Branch to Timer Channel 0 State 0
 CCF3  43                deca                                  ; Decrement Accumulator A
 CCF4  2733              beq    tc0state1                      ; Branch to Timer Channel 0 State 1
 CCF6  3D                rts
 CCF7                    
 CCF7            ;================ Timer Channel 0 State 0 - Timer Initialization ===============
 CCF7            
 CCF7            tc0state0:
 CCF7            	
 CCF7  1C002810          bset   PORTJ, $10                     ; initialize to off
 CCFB  1C002910      bset   DDRJ, $10                      ; set PORTJ to output
 CCFF  1C008001          bset   TIOS, #$01                     ; Setting TC0 for Output Compare
 CD03  1C008901          bset   TCTL2, #$01                    ; Initialize OC0 to Toggle on Successful Compare   
 CD07  1D008902          bclr   TCTL2, #$02                    ; Initialize OC0 to Toggle on Successful Compare
 CD0B  1C008E01          bset   TFLG1, #$0001                  ; Clearing the Timer Output Compare Flage if Set 
 CD0F  1C008C01      bset   TMSK1, #$01                            ; Enabling Timer Channel 0 Output Compare Interrupt
 CD13  180B010805        movb   #$01, tc0State                 ; Set Next Interrupt State to 1
 CD18  180BA00086        movb   #$A0, TSCR                     ; Enable the Timer and Stopping While in BGND Mode
 CD1D  10EF              cli                                   ; Enable Maskable Interrupts
 CD1F  FC0084            ldd    TCNT                           ; Reads Current Count and Stores it in D
 CD22  C33E80            addd   #$3E80                         ; Adds Interval Value 800 to Current Timer Count
 CD25  7C0090            std    TC0H                                                   ; Stores Interval + TCNT  
 CD28  3D                rts                                   ; Return from Subroutine
 CD29                    
 CD29            ;================== Timer Channel 0 State 1 - Arbitrary State ==================
 CD29            
 CD29            tc0state1:
 CD29            
 CD29  3D                rts                                   ; Return from Subroutine
 CD2A                    
 CD2A            ;==================== Interrupt Service Routine & Branches =====================
 CD2A            
 CD2A            TC0_ISR:
 CD2A               
 CD2A  FC0806        ldd    V_Ref                          ; Load D with V_Ref
 CD2D  F7084E        tst    loopSetFlag                    ; Test loopSetFlag
 CD30  2607          bne    OPEN_LOOP_START                ; If Open Loop Desired, Branch to OPEN_LOOP_INIT
 CD32  B30808        subd   V_Act                          ; Subtract VACT from VREF
 CD35  2B0F              bmi    SET_ERROR_NEW_NEG              ; If the N flag was set Branch to SET_ERROR_NEW_NEG
 CD37  2012              bra    SKIPtoOPEN_LOOP                ; Otherwise, Branch to SKIPtoOPEN_LOOP
 CD39                            
 CD39            OPEN_LOOP_START:
 CD39            
 CD39  B30808            subd   V_Act                          ; Subtract V_act from V_Ref
 CD3C  7C082C            STD    SS_ERROR
 CD3F  FC0806            ldd    V_Ref
 CD42  2B02              bmi    SET_ERROR_NEW_NEG              ; If the N flag was set Branch to SET_ERROR_NEW_NEG
 CD44  2005              bra    SKIPtoOPEN_LOOP                ; Otherwise, Branch to SKIPtoOPEN_LOOP
 CD46                    
 CD46            SET_ERROR_NEW_NEG:
 CD46            
 CD46  180B010874     movb   #$01, errorSign                ; Set errorSign if V_Ref-V_act Resulted in a Negative #
 CD4B            
 CD4B            SKIPtoOPEN_LOOP:   
 CD4B            
 CD4B  7C080A        std    Error                          ; Store into ERROR_NEW
 CD4E  F3080C        addd   E_Sum                          ; Add ERROR_SUM to ERROR_NEW
 CD51  280D          bvc    VALID_ESUM                     ; Exit if no overflow from ERROR_SUM+ERROR_NEW
 CD53  F7080C        tst    E_Sum                          ; If overflow, determine sign of ERROR_SUM and
 CD56  2B05          bmi    NEG_ESUM                       ; saturate accordingly.
 CD58  CC7FFF        ldd    #$7FFF                         ; Load D with maximum positive value: 32,767
 CD5B  2003          bra    VALID_ESUM                     ; Branch now that ESUM is valid
 CD5D            
 CD5D            NEG_ESUM:
 CD5D            
 CD5D  CC1F40        ldd    #8000                          ; Load D with maximum negative value: -32,768
 CD60            
 CD60            VALID_ESUM:                               ; Calculation for KI*ERROR_SUM	
 CD60            
 CD60  7C080C        std    E_Sum                          ; Store value in D into ERROR_SUM
 CD63  F7084D        tst    RUN                            ; Test RUN
 CD66  2609          bne    KEEP_ERROR_SUM                 ; If RUN = TRUE, keep current ERROR_SUM
 CD68  18030000080C     movw   #$0000, E_Sum                  ; If RUN = FALSE, set ERROR_SUM to $0000
 CD6E  FC080C        ldd    E_Sum                          ; Load D with ERROR_SUM
 CD71                
 CD71            KEEP_ERROR_SUM:
 CD71            
 CD71  FD0814        ldy    Ki                             ; Load Y with KI
 CD74  1813          emuls                                 ; (D)x(Y) ==> Y:D
 CD76  CE0400        ldx    #$400                          ; Load X with value of 1024
 CD79  1814          edivs                                 ; (Y:D)/X ==> Result into Y, Remainder ==> D
 CD7B  7D081C            sty    Kidivs                             ; Store Result in Y into Kidivs
 CD7E              
 CD7E            ; Calculation for KP*ERROR_NEW     
 CD7E               
 CD7E  FC080A        ldd    Error                          ; Load D with ERROR_NEW
 CD81  FD0818        ldy    Kp                             ; Load Y with KP
 CD84  1813          emuls                                 ; (D)x(Y) ==> Y:D
 CD86  CE0400        ldx    #$400                          ; Load X with value of 1024
 CD89  1814          edivs                                 ; (Y:D)/X ==> Result into Y, Remainder ==> D     
 CD8B  7D081A        sty    Kpdivs                         ; Store result into KPE                     
 CD8E  FC081A        ldd    Kpdivs                         ; Load D with KPE
 CD91  F70814        tst    Ki                             ; Test Ki
 CD94  2703          beq    NO_KIDIVS                      ; If Ki is zero, Get Rid of the K Division
 CD96  F3081C        addd   Kidivs                         ; Add KPE to KIE
 CD99            
 CD99            NO_KIDIVS:
 CD99            
 CD99  C30000        addd   #$0000                         ; In the KI=0 case, need to add to set V flag    
 CD9C  280D          bvc    VALID_a                        ; Exit if no overflow from KPE+KIE
 CD9E  F7081C        tst    Kidivs                         ; If overflow, determine sign of KIE and
 CDA1  2B05          bmi    NEG_a                          ; saturate accordingly.
 CDA3  CC7FFF        ldd    #$7FFF                         ; Load D with maximum positive value: 32,767
 CDA6  2003          bra    VALID_a                        ; Branch now that "a" is valid
 CDA8            NEG_a:
 CDA8            
 CDA8  CC8000        ldd    #$8000                         ; Load D with maximum negative value: -32,768    
 CDAB             
 CDAB            VALID_a:
 CDAB            
 CDAB  7C0810        std    A_Prime                        ; Store Contents of D into A_Prime
 CDAE  F7084D        tst    RUN                            ; Test Run
 CDB1  2721          beq    MOTOR_STOP                     ; If RUN=0, branch to MOTOR_STOP  
 CDB3  C3099A        addd   #$099A                         ; Add 2458 for 6 Volt offset     
 CDB6  280D          bvc    VALID_a_prime                  ; Branch now that "a prime" is valid
 CDB8  F70810        tst    A_Prime                        ; Test A_Prime
 CDBB  2B05          bmi    NEG_a_prime                    ; If A_Prime Negative, Branch to NEG_a_prime
 CDBD  CC7FFF        ldd    #$7FFF                         ; Load D with maximum positive value: 32,767
 CDC0  2003          bra    VALID_a_prime                  ; Branch now that "a prime" is valid
 CDC2                    
 CDC2            NEG_a_prime:
 CDC2            
 CDC2  CC1F40        ldd    #8000                          ; Load D with maximum negative value: -32,768
 CDC5              
 CDC5            VALID_a_prime:	
 CDC5                 
 CDC5  8C0D9A        cpd    #$0D9A                         ; Compare D to 3482
 CDC8  2A12          bpl    VDAC8.5                        ; If greater than, branch to VDAC8.5
 CDCA  8C059A        cpd    #$59A                          ; Compare D to 1434
 CDCD  2B15          bmi    VDAC3.5                        ; If less than, branch to VDAC3.5
 CDCF  7C081E        std    Dac_Value                      ; Store D into VALUE
 CDD2  2018          bra    exit_PI_CONTROL   
 CDD4            
 CDD4            MOTOR_STOP:
 CDD4            
 CDD4  1803099A081E     movw   #$99A, Dac_Value               ; 6.0V (2458)
 CDDA  2010          bra    exit_PI_CONTROL                ; Branch to exit_PI_CONTROL
 CDDC                    
 CDDC            VDAC8.5:
 CDDC            
 CDDC  18030D9A081E     movw   #$D9A, Dac_Value               ; 8.5V (3482) 
 CDE2  2008          bra    exit_PI_CONTROL                ; Branch to exit_PI_CONTROL
 CDE4                    
 CDE4            VDAC3.5:	  
 CDE4             
 CDE4  1803059A081E     movw   #$59A, Dac_Value               ; 3.5V (1434)      
 CDEA  2000          bra    exit_PI_CONTROL                ; Branch to exit_PI_CONTROL
 CDEC            
 CDEC            exit_PI_CONTROL:
 CDEC            
 CDEC  16CDF1        jsr    EFFORT_CALC                    ; Calcualte Effort Of Motor
 CDEF  2062          bra    ENCODER_READ                   ; Branch to ENCODER_READ
 CDF1            
 CDF1            EFFORT_CALC:
 CDF1            
 CDF1            
 CDF1  FC081E        ldd    Dac_Value
 CDF4  8C099A            cpd    #$099A
 CDF7  2518              blo    EFFORT_NEGATIVE
 CDF9  83099A            subd   #$099A
 CDFC  7C083F            std        Dac_ValueMinusSixVolts
 CDFF  CD0064            ldy        #$0064
 CE02  1813              emuls
 CE04  7C0841            std        Dac_ValueTimesHundred
 CE07  FC0841            ldd        Dac_ValueTimesHundred
 CE0A  CE0400            ldx        #$0400
 CE0D  1815              idivs
 CE0F  201B              bra        EFFORT_POS
 CE11                       
 CE11            EFFORT_NEGATIVE:
 CE11            
 CE11  CC099A        ldd    #$099A
 CE14  B3081E            subd   Dac_Value
 CE17  7C083F            std        Dac_ValueMinusSixVolts
 CE1A  CD0064            ldy        #$0064
 CE1D  1813              emuls
 CE1F  7C0841            std        Dac_ValueTimesHundred
 CE22  FC0841            ldd        Dac_ValueTimesHundred
 CE25  CE0400            ldx        #$0400
 CE28  1815              idivs
 CE2A  2017              bra    EFFORT_NEG          
 CE2C            
 CE2C            EFFORT_POS:
 CE2C            
 CE2C  CD0BBE        ldy    #EFFORT_BUF
 CE2F  1808402B          movb   #'+',0,Y                           ; Move '-' into the First Buffer Address
 CE33  8E0064        cpx    #$0064
 CE36  2204              bhi        EFFORT_SAT
 CE38  7E0824            stx        Effort
 CE3B  3D                rts
 CE3C                    
 CE3C            EFFORT_SAT:
 CE3C            	
 CE3C  180300640824      movw   #$0064, Effort
 CE42  3D                rts
 CE43                    
 CE43            EFFORT_NEG:
 CE43            
 CE43  CD0BBE        ldy    #EFFORT_BUF
 CE46  1808402D          movb   #'-',0,Y                           ; Move '-' into the First Buffer Address        
 CE4A  8E0064        cpx    #$0064
 CE4D  22ED              bhi        EFFORT_SAT
 CE4F  7E0824            stx        Effort
 CE52  3D                rts     
 CE53            
 CE53            ENCODER_READ:
 CE53            	   
 CE53  FC0280            ldd    ENCODER                        ; Load D with current ENCODER value (THETA_NEW)
 CE56  7C0820        std    Theta_New                      ; Store Encoder Value in Theta_New
 CE59  B30822        subd   Theta_Old                      ; Subtract THETA_OLD from D
 CE5C  2B02              bmi    SET_VACT_NEG                   ; If Subtraction is Negative, Branch to SET_VACT_NEG
 CE5E  2005              bra    SKIP_NEGATING_VACT             ; Otherwise, Branch to SKIP_NEGATING_VACT
 CE60            
 CE60            SET_VACT_NEG:
 CE60            
 CE60  180B010872     movb   #$01, VActSign                 ; Set the VActSign to TRUE
 CE65            
 CE65            SKIP_NEGATING_VACT:	
 CE65               	
 CE65  7C0808        std    V_Act                          ; Store Contents of D into V_act
 CE68  180408200822     movw   Theta_New,Theta_Old            ; Move Current Theta_Value into Theta_Old
 CE6E  180B010853     movb   #$01, VActFlag                 ; Set VActFlag
 CE73  180B010855     movb   #$01, errorFlag                ; Set errorFlag
 CE78  180B010854     movb   #$01, effortFlag               ; Set effortFlag
 CE7D  180B01086D        movb   #$01, updateValuesFlag         ; Set updateValuesFlag
 CE82             
 CE82            OUTDAC:
 CE82            
 CE82  FC081E       ldd     Dac_Value                      ; Load Accumulator D With VALUE
 CE85  7A0301       staa    $0301                          ; Store Address of DACs MSB in A
 CE88  7B0300       stab    $0300                          ; Store Address of DACs LSB in B
 CE8B  1D002810     bclr    PORTJ, pin5                    ; Clear pin 5 in Port J
 CE8F  1C002810     bset    PORTJ, pin5                    ; Set pin 5 in Port J
 CE93            
 CE93            SCOPE_CALC:
 CE93               
 CE93  FC0808       LDD     V_Act
 CE96  CD000D       LDY     #$0D
 CE99  1813         EMULS
 CE9B  C30800       ADDD    #$800
 CE9E  7C082A       STD     DAC_PLUS_FIVE
 CEA1  2000         BRA     CHANB_OUTDAC
 CEA3               
 CEA3            CHANB_OUTDAC:
 CEA3            
 CEA3  FC082A       LDD     DAC_PLUS_FIVE                  ; Load Accumulator D With VALUE
 CEA6  7A0303       STAA    $0303                          ; Store Address of DACs MSB in B
 CEA9  7B0302       STAB    $0302                          ; Store Address of DACs LSB in B
 CEAC  1D002810     BCLR    PORTJ, pin5                    ; Clear pin 5 in Port J
 CEB0  1C002810     BSET    PORTJ, pin5                    ; Set pin 5 in Port J
 CEB4               
 CEB4            FINAL_ISR_CHECK:
 CEB4            
 CEB4  F7084E            tst    loopSetFlag
 CEB7  2602              bne    SET_SS_ERROR
 CEB9  2006              bra    LCD_COUNTER_CHECK
 CEBB            
 CEBB            SET_SS_ERROR:
 CEBB            
 CEBB  1804082C080A     movw   SS_ERROR, Error
 CEC1                    
 CEC1            LCD_COUNTER_CHECK:
 CEC1            	
 CEC1  F70845        tst    LCDUpdateCounter               ; Test LCDUpdateCounter
 CEC4  260A              bne        NOT_YET                        ; If LCDUpdateCounter is TRUE, Branch to LCDUpdateCounter
 CEC6  730845            dec        LCDUpdateCounter               ; Otherwise Branch to LCDUpdateCounter
 CEC9  180B010851        movb   #$01, LCDUpdateFlag            ; Set LCDUpdateFlag
 CECE  2005              bra        ISR_DONE                       ; Branch to ISR_DONE
 CED0            
 CED0            NOT_YET:
 CED0                
 CED0  730845            dec        LCDUpdateCounter               ; Decrement LCDUpdateCounter
 CED3  2000              bra        ISR_DONE                       ; Branch to ISR_DONE
 CED5                    
 CED5            ISR_DONE:
 CED5             
 CED5  FC0090            ldd        TC0H                                       ; Grab the Timer Count Corresponding to ISR
 CED8  C33E80            addd   #$3E80                                     ; Add the Interval to The Current Timer Count
 CEDB  7C0090            std        TC0H                                       ; Store the New Timer Count Into the TC0 CR
 CEDE  B6008E            ldaa   TFLG1                          ; LOAD TIMER FLAG ONTO ACC. A
 CEE1  8A01              oraa   #01                            ; CLEAR CONTENTS (TIMER FLAG) OF ACC. A
 CEE3  7A008E            staa   TFLG1                          ; LOAD ACC. A BACK INTO TIMER FLAG
 CEE6  0B                rti
 CEE7              
 CEE7            ;===============================================================================
 CEE7            
                .area interrupt_vectors (abs)
                
                        .org   $FFEE                          ; Address of Next Interrupt        
 FFEE  CD2A              .word  TC0_ISR                        ; Load Interrupt Address
                        .org    $FFFE                         ; At Reset Vector Location
 FFFE  C000              .word   __start                       ; Load Starting Address
 10000            
 10000            
 10000            
 10000            
 10000               
 10000                
 10000               
